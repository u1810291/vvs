# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

type FilestoreSave {
    uri: String!
}

type LoginOutput {
    refreshToken: String
    token: String
    user: UserObject
}

type UserObject {
    active: Boolean
    birthDate: date
    breachedPasswordLastCheckedInstant: timestamp
    connectorId: uuid
    email: String
    expiry: timestamp
    firstName: String
    fullName: String
    id: uuid!
    imageUrl: String
    lastLoginInstant: timestamp
    lastName: String
    middleName: String
    mobilePhone: String
    passwordChangeRequired: Boolean
    passwordLastUpdateInstant: timestamp
    username: String
    usernameStatus: String
    verified: Boolean
}

type UserOutput {
    user: UserObject!
}

"columns and relationships of \"central\""
type central {
    comment: String!
    value: String!
}

"aggregated selection of \"central\""
type central_aggregate {
    aggregate: central_aggregate_fields
    nodes: [central!]!
}

"aggregate fields of \"central\""
type central_aggregate_fields {
    count(columns: [central_select_column!], distinct: Boolean): Int!
    max: central_max_fields
    min: central_min_fields
}

"aggregate max on columns"
type central_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type central_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"central\""
type central_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [central!]!
}

"columns and relationships of \"city\""
type city {
    comment: String!
    value: String!
}

"aggregated selection of \"city\""
type city_aggregate {
    aggregate: city_aggregate_fields
    nodes: [city!]!
}

"aggregate fields of \"city\""
type city_aggregate_fields {
    count(columns: [city_select_column!], distinct: Boolean): Int!
    max: city_max_fields
    min: city_min_fields
}

"aggregate max on columns"
type city_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type city_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"city\""
type city_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [city!]!
}

"columns and relationships of \"coresppersons\""
type coresppersons {
    Id: String
    SendMail: String
    SendSMS: String
    ShowAtWorkTimeOnly: String
    address: String
    category: Int
    deleted: Boolean!
    email: String
    id: String!
    index: Int
    key: String
    letConnect: Boolean!
    letSeeInvoices: Boolean!
    name: String
    notes: String
    objectid: Int
    office: String
    onvacationfrom: String
    onvacationto: String
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int
}

"aggregated selection of \"coresppersons\""
type coresppersons_aggregate {
    aggregate: coresppersons_aggregate_fields
    nodes: [coresppersons!]!
}

"aggregate fields of \"coresppersons\""
type coresppersons_aggregate_fields {
    avg: coresppersons_avg_fields
    count(columns: [coresppersons_select_column!], distinct: Boolean): Int!
    max: coresppersons_max_fields
    min: coresppersons_min_fields
    stddev: coresppersons_stddev_fields
    stddev_pop: coresppersons_stddev_pop_fields
    stddev_samp: coresppersons_stddev_samp_fields
    sum: coresppersons_sum_fields
    var_pop: coresppersons_var_pop_fields
    var_samp: coresppersons_var_samp_fields
    variance: coresppersons_variance_fields
}

"aggregate avg on columns"
type coresppersons_avg_fields {
    category: Float
    index: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate max on columns"
type coresppersons_max_fields {
    Id: String
    SendMail: String
    SendSMS: String
    ShowAtWorkTimeOnly: String
    address: String
    category: Int
    email: String
    id: String
    index: Int
    key: String
    name: String
    notes: String
    objectid: Int
    office: String
    onvacationfrom: String
    onvacationto: String
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int
}

"aggregate min on columns"
type coresppersons_min_fields {
    Id: String
    SendMail: String
    SendSMS: String
    ShowAtWorkTimeOnly: String
    address: String
    category: Int
    email: String
    id: String
    index: Int
    key: String
    name: String
    notes: String
    objectid: Int
    office: String
    onvacationfrom: String
    onvacationto: String
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int
}

"response of any mutation on the table \"coresppersons\""
type coresppersons_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [coresppersons!]!
}

"aggregate stddev on columns"
type coresppersons_stddev_fields {
    category: Float
    index: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate stddev_pop on columns"
type coresppersons_stddev_pop_fields {
    category: Float
    index: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate stddev_samp on columns"
type coresppersons_stddev_samp_fields {
    category: Float
    index: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate sum on columns"
type coresppersons_sum_fields {
    category: Int
    index: Int
    objectid: Int
    personid: Int
    position: Int
}

"aggregate var_pop on columns"
type coresppersons_var_pop_fields {
    category: Float
    index: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate var_samp on columns"
type coresppersons_var_samp_fields {
    category: Float
    index: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate variance on columns"
type coresppersons_variance_fields {
    category: Float
    index: Float
    objectid: Float
    personid: Float
    position: Float
}

"columns and relationships of \"corresppersons\""
type corresppersons {
    SendMail: String!
    SendSMS: String!
    ShowAtWorkTimeOnly: String!
    address: String
    category: Int
    email: String
    id: Int!
    key: String
    name: String
    notes: String
    objectid: Int!
    office: String
    onvacationfrom: datetime
    onvacationto: datetime
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int!
}

"aggregated selection of \"corresppersons\""
type corresppersons_aggregate {
    aggregate: corresppersons_aggregate_fields
    nodes: [corresppersons!]!
}

"aggregate fields of \"corresppersons\""
type corresppersons_aggregate_fields {
    avg: corresppersons_avg_fields
    count(column: corresppersons_select_column, distinct: Boolean): Int!
    max: corresppersons_max_fields
    min: corresppersons_min_fields
    stddev: corresppersons_stddev_fields
    stddev_pop: corresppersons_stddev_pop_fields
    stddev_samp: corresppersons_stddev_samp_fields
    sum: corresppersons_sum_fields
    var_pop: corresppersons_var_pop_fields
    var_samp: corresppersons_var_samp_fields
    variance: corresppersons_variance_fields
}

"aggregate avg on columns"
type corresppersons_avg_fields {
    category: Float
    id: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate max on columns"
type corresppersons_max_fields {
    SendMail: String
    SendSMS: String
    ShowAtWorkTimeOnly: String
    address: String
    category: Int
    email: String
    id: Int
    key: String
    name: String
    notes: String
    objectid: Int
    office: String
    onvacationfrom: datetime
    onvacationto: datetime
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int
}

"aggregate min on columns"
type corresppersons_min_fields {
    SendMail: String
    SendSMS: String
    ShowAtWorkTimeOnly: String
    address: String
    category: Int
    email: String
    id: Int
    key: String
    name: String
    notes: String
    objectid: Int
    office: String
    onvacationfrom: datetime
    onvacationto: datetime
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int
}

"response of any mutation on the table \"corresppersons\""
type corresppersons_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [corresppersons!]!
}

"aggregate stddev on columns"
type corresppersons_stddev_fields {
    category: Float
    id: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate stddev_pop on columns"
type corresppersons_stddev_pop_fields {
    category: Float
    id: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate stddev_samp on columns"
type corresppersons_stddev_samp_fields {
    category: Float
    id: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate sum on columns"
type corresppersons_sum_fields {
    category: Int
    id: Int
    objectid: Int
    personid: Int
    position: Int
}

"aggregate var_pop on columns"
type corresppersons_var_pop_fields {
    category: Float
    id: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate var_samp on columns"
type corresppersons_var_samp_fields {
    category: Float
    id: Float
    objectid: Float
    personid: Float
    position: Float
}

"aggregate variance on columns"
type corresppersons_variance_fields {
    category: Float
    id: Float
    objectid: Float
    personid: Float
    position: Float
}

"main data regarding crew unit"
type crew {
    "An object relationship"
    breaches: crew_breach
    "An object relationship"
    calendar: crew_calendar
    driver_name: String
    id: uuid!
    is_assigned_automatically: Boolean!
    is_assigned_while_in_breaks: Boolean!
    name: String
    "An array relationship"
    permissions(
        "distinct select on columns"
        distinct_on: [crew_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_permission_order_by!],
        "filter the rows returned"
        where: crew_permission_bool_exp
    ): [crew_permission!]!
    "An aggregate relationship"
    permissions_aggregate(
        "distinct select on columns"
        distinct_on: [crew_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_permission_order_by!],
        "filter the rows returned"
        where: crew_permission_bool_exp
    ): crew_permission_aggregate!
    phone_number: String
    status: crew_status_enum
    to_call_after: String
    "An array relationship"
    zone(
        "distinct select on columns"
        distinct_on: [crew_zone_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_zone_order_by!],
        "filter the rows returned"
        where: crew_zone_bool_exp
    ): [crew_zone!]!
    "An aggregate relationship"
    zone_aggregate(
        "distinct select on columns"
        distinct_on: [crew_zone_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_zone_order_by!],
        "filter the rows returned"
        where: crew_zone_bool_exp
    ): crew_zone_aggregate!
}

"aggregated selection of \"crew\""
type crew_aggregate {
    aggregate: crew_aggregate_fields
    nodes: [crew!]!
}

"aggregate fields of \"crew\""
type crew_aggregate_fields {
    count(columns: [crew_select_column!], distinct: Boolean): Int!
    max: crew_max_fields
    min: crew_min_fields
}

"represents a violation of the boundaries of the dislocation zone"
type crew_breach {
    "An object relationship"
    crew: crew
    crew_id: uuid
    driver_id: uuid
    end_time: timestamptz
    id: uuid!
    nodes(
        "JSON select path"
        path: String
    ): json
    start_time: timestamptz
}

"aggregated selection of \"crew_breach\""
type crew_breach_aggregate {
    aggregate: crew_breach_aggregate_fields
    nodes: [crew_breach!]!
}

"aggregate fields of \"crew_breach\""
type crew_breach_aggregate_fields {
    count(columns: [crew_breach_select_column!], distinct: Boolean): Int!
    max: crew_breach_max_fields
    min: crew_breach_min_fields
}

"aggregate max on columns"
type crew_breach_max_fields {
    crew_id: uuid
    driver_id: uuid
    end_time: timestamptz
    id: uuid
    start_time: timestamptz
}

"aggregate min on columns"
type crew_breach_min_fields {
    crew_id: uuid
    driver_id: uuid
    end_time: timestamptz
    id: uuid
    start_time: timestamptz
}

"response of any mutation on the table \"crew_breach\""
type crew_breach_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [crew_breach!]!
}

"columns and relationships of \"crew_calendar\""
type crew_calendar {
    created_at: timestamptz!
    "An object relationship"
    crew: crew!
    crew_id: uuid!
    dislocation_zone_id: uuid!
    end_time: interval!
    id: uuid!
    start_time: interval!
    updated_at: timestamptz!
    week_day: Int
}

"aggregated selection of \"crew_calendar\""
type crew_calendar_aggregate {
    aggregate: crew_calendar_aggregate_fields
    nodes: [crew_calendar!]!
}

"aggregate fields of \"crew_calendar\""
type crew_calendar_aggregate_fields {
    avg: crew_calendar_avg_fields
    count(columns: [crew_calendar_select_column!], distinct: Boolean): Int!
    max: crew_calendar_max_fields
    min: crew_calendar_min_fields
    stddev: crew_calendar_stddev_fields
    stddev_pop: crew_calendar_stddev_pop_fields
    stddev_samp: crew_calendar_stddev_samp_fields
    sum: crew_calendar_sum_fields
    var_pop: crew_calendar_var_pop_fields
    var_samp: crew_calendar_var_samp_fields
    variance: crew_calendar_variance_fields
}

"aggregate avg on columns"
type crew_calendar_avg_fields {
    week_day: Float
}

"aggregate max on columns"
type crew_calendar_max_fields {
    created_at: timestamptz
    crew_id: uuid
    dislocation_zone_id: uuid
    id: uuid
    updated_at: timestamptz
    week_day: Int
}

"aggregate min on columns"
type crew_calendar_min_fields {
    created_at: timestamptz
    crew_id: uuid
    dislocation_zone_id: uuid
    id: uuid
    updated_at: timestamptz
    week_day: Int
}

"response of any mutation on the table \"crew_calendar\""
type crew_calendar_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [crew_calendar!]!
}

"aggregate stddev on columns"
type crew_calendar_stddev_fields {
    week_day: Float
}

"aggregate stddev_pop on columns"
type crew_calendar_stddev_pop_fields {
    week_day: Float
}

"aggregate stddev_samp on columns"
type crew_calendar_stddev_samp_fields {
    week_day: Float
}

"aggregate sum on columns"
type crew_calendar_sum_fields {
    week_day: Int
}

"aggregate var_pop on columns"
type crew_calendar_var_pop_fields {
    week_day: Float
}

"aggregate var_samp on columns"
type crew_calendar_var_samp_fields {
    week_day: Float
}

"aggregate variance on columns"
type crew_calendar_variance_fields {
    week_day: Float
}

"id should match user from user service (FusionAuth)"
type crew_driver {
    created_at: timestamptz!
    crew_id: uuid
    id: uuid!
    updated_at: timestamptz!
}

"aggregated selection of \"crew_driver\""
type crew_driver_aggregate {
    aggregate: crew_driver_aggregate_fields
    nodes: [crew_driver!]!
}

"aggregate fields of \"crew_driver\""
type crew_driver_aggregate_fields {
    count(columns: [crew_driver_select_column!], distinct: Boolean): Int!
    max: crew_driver_max_fields
    min: crew_driver_min_fields
}

"aggregate max on columns"
type crew_driver_max_fields {
    created_at: timestamptz
    crew_id: uuid
    id: uuid
    updated_at: timestamptz
}

"aggregate min on columns"
type crew_driver_min_fields {
    created_at: timestamptz
    crew_id: uuid
    id: uuid
    updated_at: timestamptz
}

"response of any mutation on the table \"crew_driver\""
type crew_driver_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [crew_driver!]!
}

"aggregate max on columns"
type crew_max_fields {
    driver_name: String
    id: uuid
    name: String
    phone_number: String
    to_call_after: String
}

"aggregate min on columns"
type crew_min_fields {
    driver_name: String
    id: uuid
    name: String
    phone_number: String
    to_call_after: String
}

"response of any mutation on the table \"crew\""
type crew_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [crew!]!
}

"columns and relationships of \"crew_permission\""
type crew_permission {
    comment: String
    created_at: timestamptz!
    "An object relationship"
    crew: crew!
    crew_id: uuid!
    id: uuid!
    "An object relationship"
    request: crew_request!
    request_id: String!
    status: crew_request_status_enum!
    updated_at: timestamptz!
}

"aggregated selection of \"crew_permission\""
type crew_permission_aggregate {
    aggregate: crew_permission_aggregate_fields
    nodes: [crew_permission!]!
}

"aggregate fields of \"crew_permission\""
type crew_permission_aggregate_fields {
    count(columns: [crew_permission_select_column!], distinct: Boolean): Int!
    max: crew_permission_max_fields
    min: crew_permission_min_fields
}

"aggregate max on columns"
type crew_permission_max_fields {
    comment: String
    created_at: timestamptz
    crew_id: uuid
    id: uuid
    request_id: String
    updated_at: timestamptz
}

"aggregate min on columns"
type crew_permission_min_fields {
    comment: String
    created_at: timestamptz
    crew_id: uuid
    id: uuid
    request_id: String
    updated_at: timestamptz
}

"response of any mutation on the table \"crew_permission\""
type crew_permission_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [crew_permission!]!
}

"columns and relationships of \"crew_request\""
type crew_request {
    duration: interval!
    "An array relationship"
    permissions(
        "distinct select on columns"
        distinct_on: [crew_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_permission_order_by!],
        "filter the rows returned"
        where: crew_permission_bool_exp
    ): [crew_permission!]!
    "An aggregate relationship"
    permissions_aggregate(
        "distinct select on columns"
        distinct_on: [crew_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_permission_order_by!],
        "filter the rows returned"
        where: crew_permission_bool_exp
    ): crew_permission_aggregate!
    value: String!
}

"aggregated selection of \"crew_request\""
type crew_request_aggregate {
    aggregate: crew_request_aggregate_fields
    nodes: [crew_request!]!
}

"aggregate fields of \"crew_request\""
type crew_request_aggregate_fields {
    count(columns: [crew_request_select_column!], distinct: Boolean): Int!
    max: crew_request_max_fields
    min: crew_request_min_fields
}

"aggregate max on columns"
type crew_request_max_fields {
    value: String
}

"aggregate min on columns"
type crew_request_min_fields {
    value: String
}

"response of any mutation on the table \"crew_request\""
type crew_request_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [crew_request!]!
}

"columns and relationships of \"crew_request_status\""
type crew_request_status {
    comment: String
    value: String!
}

"aggregated selection of \"crew_request_status\""
type crew_request_status_aggregate {
    aggregate: crew_request_status_aggregate_fields
    nodes: [crew_request_status!]!
}

"aggregate fields of \"crew_request_status\""
type crew_request_status_aggregate_fields {
    count(columns: [crew_request_status_select_column!], distinct: Boolean): Int!
    max: crew_request_status_max_fields
    min: crew_request_status_min_fields
}

"aggregate max on columns"
type crew_request_status_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type crew_request_status_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"crew_request_status\""
type crew_request_status_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [crew_request_status!]!
}

"columns and relationships of \"crew_status\""
type crew_status {
    comment: String
    value: String!
}

"aggregated selection of \"crew_status\""
type crew_status_aggregate {
    aggregate: crew_status_aggregate_fields
    nodes: [crew_status!]!
}

"aggregate fields of \"crew_status\""
type crew_status_aggregate_fields {
    count(columns: [crew_status_select_column!], distinct: Boolean): Int!
    max: crew_status_max_fields
    min: crew_status_min_fields
}

"aggregate max on columns"
type crew_status_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type crew_status_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"crew_status\""
type crew_status_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [crew_status!]!
}

"Crew Dislocation Zones"
type crew_zone {
    "An object relationship"
    crew: crew
    crew_id: uuid
    id: uuid!
    name: String!
    nodes(
        "JSON select path"
        path: String
    ): json!
}

"aggregated selection of \"crew_zone\""
type crew_zone_aggregate {
    aggregate: crew_zone_aggregate_fields
    nodes: [crew_zone!]!
}

"aggregate fields of \"crew_zone\""
type crew_zone_aggregate_fields {
    count(columns: [crew_zone_select_column!], distinct: Boolean): Int!
    max: crew_zone_max_fields
    min: crew_zone_min_fields
}

"aggregate max on columns"
type crew_zone_max_fields {
    crew_id: uuid
    id: uuid
    name: String
}

"aggregate min on columns"
type crew_zone_min_fields {
    crew_id: uuid
    id: uuid
    name: String
}

"response of any mutation on the table \"crew_zone\""
type crew_zone_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [crew_zone!]!
}

type deleteQuery {
    userId: String
}

"columns and relationships of \"event_status\""
type event_status {
    description: String!
    value: String!
}

"aggregated selection of \"event_status\""
type event_status_aggregate {
    aggregate: event_status_aggregate_fields
    nodes: [event_status!]!
}

"aggregate fields of \"event_status\""
type event_status_aggregate_fields {
    count(columns: [event_status_select_column!], distinct: Boolean): Int!
    max: event_status_max_fields
    min: event_status_min_fields
}

"aggregate max on columns"
type event_status_max_fields {
    description: String
    value: String
}

"aggregate min on columns"
type event_status_min_fields {
    description: String
    value: String
}

"response of any mutation on the table \"event_status\""
type event_status_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [event_status!]!
}

"columns and relationships of \"events\""
type events {
    created_at: timestamptz!
    crew_id: uuid
    description: String
    id: uuid!
    name: String
    object_id: uuid
    provider_id: Int
    provider_name: provider_enum
    status: event_status_enum
    updated_at: timestamptz!
}

"aggregated selection of \"events\""
type events_aggregate {
    aggregate: events_aggregate_fields
    nodes: [events!]!
}

"aggregate fields of \"events\""
type events_aggregate_fields {
    avg: events_avg_fields
    count(columns: [events_select_column!], distinct: Boolean): Int!
    max: events_max_fields
    min: events_min_fields
    stddev: events_stddev_fields
    stddev_pop: events_stddev_pop_fields
    stddev_samp: events_stddev_samp_fields
    sum: events_sum_fields
    var_pop: events_var_pop_fields
    var_samp: events_var_samp_fields
    variance: events_variance_fields
}

"aggregate avg on columns"
type events_avg_fields {
    provider_id: Float
}

"aggregate max on columns"
type events_max_fields {
    created_at: timestamptz
    crew_id: uuid
    description: String
    id: uuid
    name: String
    object_id: uuid
    provider_id: Int
    updated_at: timestamptz
}

"aggregate min on columns"
type events_min_fields {
    created_at: timestamptz
    crew_id: uuid
    description: String
    id: uuid
    name: String
    object_id: uuid
    provider_id: Int
    updated_at: timestamptz
}

"response of any mutation on the table \"events\""
type events_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [events!]!
}

"aggregate stddev on columns"
type events_stddev_fields {
    provider_id: Float
}

"aggregate stddev_pop on columns"
type events_stddev_pop_fields {
    provider_id: Float
}

"aggregate stddev_samp on columns"
type events_stddev_samp_fields {
    provider_id: Float
}

"aggregate sum on columns"
type events_sum_fields {
    provider_id: Int
}

"aggregate var_pop on columns"
type events_var_pop_fields {
    provider_id: Float
}

"aggregate var_samp on columns"
type events_var_samp_fields {
    provider_id: Float
}

"aggregate variance on columns"
type events_variance_fields {
    provider_id: Float
}

"columns and relationships of \"eventsdescription\""
type eventsdescription {
    Id: Int!
    SMSid: Int
    SMSsender: Int!
    SendMail: String!
    SendSMS: String!
    SendSMStoPerson: String!
    SendViaTCP: String!
    clasificator: String
    eMailId: Int
    exampleid: Int!
    expireAfter: datetime
    forward: String!
    forwardedobjectid: Int
    isRestoreEvent: Boolean!
    limit_sms: String!
    name: String
    objectnr: Int!
    reaction: Int!
    relationID: Int!
    seekRestore: String!
    sms_limit_time: Int!
    sound: String!
    useinterval: String!
    value: String
    valuefrom: String!
    valueto: String!
    window: String!
    zonenr: String
}

"aggregated selection of \"eventsdescription\""
type eventsdescription_aggregate {
    aggregate: eventsdescription_aggregate_fields
    nodes: [eventsdescription!]!
}

"aggregate fields of \"eventsdescription\""
type eventsdescription_aggregate_fields {
    avg: eventsdescription_avg_fields
    count(column: eventsdescription_select_column, distinct: Boolean): Int!
    max: eventsdescription_max_fields
    min: eventsdescription_min_fields
    stddev: eventsdescription_stddev_fields
    stddev_pop: eventsdescription_stddev_pop_fields
    stddev_samp: eventsdescription_stddev_samp_fields
    sum: eventsdescription_sum_fields
    var_pop: eventsdescription_var_pop_fields
    var_samp: eventsdescription_var_samp_fields
    variance: eventsdescription_variance_fields
}

"aggregate avg on columns"
type eventsdescription_avg_fields {
    Id: Float
    SMSid: Float
    SMSsender: Float
    eMailId: Float
    exampleid: Float
    forwardedobjectid: Float
    objectnr: Float
    reaction: Float
    relationID: Float
    sms_limit_time: Float
}

"aggregate max on columns"
type eventsdescription_max_fields {
    Id: Int
    SMSid: Int
    SMSsender: Int
    SendMail: String
    SendSMS: String
    SendSMStoPerson: String
    SendViaTCP: String
    clasificator: String
    eMailId: Int
    exampleid: Int
    expireAfter: datetime
    forward: String
    forwardedobjectid: Int
    limit_sms: String
    name: String
    objectnr: Int
    reaction: Int
    relationID: Int
    seekRestore: String
    sms_limit_time: Int
    sound: String
    useinterval: String
    value: String
    valuefrom: String
    valueto: String
    window: String
    zonenr: String
}

"aggregate min on columns"
type eventsdescription_min_fields {
    Id: Int
    SMSid: Int
    SMSsender: Int
    SendMail: String
    SendSMS: String
    SendSMStoPerson: String
    SendViaTCP: String
    clasificator: String
    eMailId: Int
    exampleid: Int
    expireAfter: datetime
    forward: String
    forwardedobjectid: Int
    limit_sms: String
    name: String
    objectnr: Int
    reaction: Int
    relationID: Int
    seekRestore: String
    sms_limit_time: Int
    sound: String
    useinterval: String
    value: String
    valuefrom: String
    valueto: String
    window: String
    zonenr: String
}

"response of any mutation on the table \"eventsdescription\""
type eventsdescription_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [eventsdescription!]!
}

"aggregate stddev on columns"
type eventsdescription_stddev_fields {
    Id: Float
    SMSid: Float
    SMSsender: Float
    eMailId: Float
    exampleid: Float
    forwardedobjectid: Float
    objectnr: Float
    reaction: Float
    relationID: Float
    sms_limit_time: Float
}

"aggregate stddev_pop on columns"
type eventsdescription_stddev_pop_fields {
    Id: Float
    SMSid: Float
    SMSsender: Float
    eMailId: Float
    exampleid: Float
    forwardedobjectid: Float
    objectnr: Float
    reaction: Float
    relationID: Float
    sms_limit_time: Float
}

"aggregate stddev_samp on columns"
type eventsdescription_stddev_samp_fields {
    Id: Float
    SMSid: Float
    SMSsender: Float
    eMailId: Float
    exampleid: Float
    forwardedobjectid: Float
    objectnr: Float
    reaction: Float
    relationID: Float
    sms_limit_time: Float
}

"aggregate sum on columns"
type eventsdescription_sum_fields {
    Id: Int
    SMSid: Int
    SMSsender: Int
    eMailId: Int
    exampleid: Int
    forwardedobjectid: Int
    objectnr: Int
    reaction: Int
    relationID: Int
    sms_limit_time: Int
}

"aggregate var_pop on columns"
type eventsdescription_var_pop_fields {
    Id: Float
    SMSid: Float
    SMSsender: Float
    eMailId: Float
    exampleid: Float
    forwardedobjectid: Float
    objectnr: Float
    reaction: Float
    relationID: Float
    sms_limit_time: Float
}

"aggregate var_samp on columns"
type eventsdescription_var_samp_fields {
    Id: Float
    SMSid: Float
    SMSsender: Float
    eMailId: Float
    exampleid: Float
    forwardedobjectid: Float
    objectnr: Float
    reaction: Float
    relationID: Float
    sms_limit_time: Float
}

"aggregate variance on columns"
type eventsdescription_variance_fields {
    Id: Float
    SMSid: Float
    SMSsender: Float
    eMailId: Float
    exampleid: Float
    forwardedobjectid: Float
    objectnr: Float
    reaction: Float
    relationID: Float
    sms_limit_time: Float
}

"filters for vvs"
type filters {
    Id: uuid!
    crew: String
    dashboardList(
        "JSON select path"
        path: String
    ): jsonb
    date: String
    driver: String
    filterName: String
    filterShortName: String
    group: String
    id: String!
    inTime: String
    object: String
    objectAddress: String
    operator: String
    reason: String
    savedToFavorite: Boolean!
    savedToMenu: Boolean!
    status: String
    type: String
    userId: String!
}

"aggregated selection of \"filters\""
type filters_aggregate {
    aggregate: filters_aggregate_fields
    nodes: [filters!]!
}

"aggregate fields of \"filters\""
type filters_aggregate_fields {
    count(columns: [filters_select_column!], distinct: Boolean): Int!
    max: filters_max_fields
    min: filters_min_fields
}

"aggregate max on columns"
type filters_max_fields {
    Id: uuid
    crew: String
    date: String
    driver: String
    filterName: String
    filterShortName: String
    group: String
    id: String
    inTime: String
    object: String
    objectAddress: String
    operator: String
    reason: String
    status: String
    type: String
    userId: String
}

"aggregate min on columns"
type filters_min_fields {
    Id: uuid
    crew: String
    date: String
    driver: String
    filterName: String
    filterShortName: String
    group: String
    id: String
    inTime: String
    object: String
    objectAddress: String
    operator: String
    reason: String
    status: String
    type: String
    userId: String
}

"response of any mutation on the table \"filters\""
type filters_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [filters!]!
}

type forgotOutput {
    changePasswordId: String!
}

type loginOutput {
    refreshToken: String
    token: String
}

"columns and relationships of \"events\""
type monas_events {
    ObjectName: String
    Remind: String!
    RemindAtTime: datetime
    RemindFromTime: datetime
    RemindInHours: Int
    RemindInMinutes: Int
    Reminder: String!
    action: Int!
    addedtoarchivetime: datetime
    clasificator: String
    closedby: String
    eventcode: String
    eventdescid: Int
    eventname: String
    eventsource: Int
    groupnr: Int
    id: Int!
    linename: String
    linenr: Int
    lockedby: Int!
    objectdbid: Int
    objectnr: Int
    playsound: String
    priority: Int!
    reactedby: String
    reactedtime: datetime
    reactionid: Int
    reactiontype: Int
    receivedlevel: Int
    receivedtime: datetime
    receivername: String
    receivernr: Int
    relationid: Int
    repeated: String!
    retranslator: Int
    retranslatorlevel: Int
    selectable: Int!
    status: Int!
    unifier_id: Int
    wasDriverAcquired: Boolean!
    zonenumber: String
}

"aggregated selection of \"events\""
type monas_events_aggregate {
    aggregate: monas_events_aggregate_fields
    nodes: [monas_events!]!
}

"aggregate fields of \"events\""
type monas_events_aggregate_fields {
    avg: monas_events_avg_fields
    count(column: monas_events_select_column, distinct: Boolean): Int!
    max: monas_events_max_fields
    min: monas_events_min_fields
    stddev: monas_events_stddev_fields
    stddev_pop: monas_events_stddev_pop_fields
    stddev_samp: monas_events_stddev_samp_fields
    sum: monas_events_sum_fields
    var_pop: monas_events_var_pop_fields
    var_samp: monas_events_var_samp_fields
    variance: monas_events_variance_fields
}

"aggregate avg on columns"
type monas_events_avg_fields {
    RemindInHours: Float
    RemindInMinutes: Float
    action: Float
    eventdescid: Float
    eventsource: Float
    groupnr: Float
    id: Float
    linenr: Float
    lockedby: Float
    objectdbid: Float
    objectnr: Float
    priority: Float
    reactionid: Float
    reactiontype: Float
    receivedlevel: Float
    receivernr: Float
    relationid: Float
    retranslator: Float
    retranslatorlevel: Float
    selectable: Float
    status: Float
    unifier_id: Float
}

"aggregate max on columns"
type monas_events_max_fields {
    ObjectName: String
    Remind: String
    RemindAtTime: datetime
    RemindFromTime: datetime
    RemindInHours: Int
    RemindInMinutes: Int
    Reminder: String
    action: Int
    addedtoarchivetime: datetime
    clasificator: String
    closedby: String
    eventcode: String
    eventdescid: Int
    eventname: String
    eventsource: Int
    groupnr: Int
    id: Int
    linename: String
    linenr: Int
    lockedby: Int
    objectdbid: Int
    objectnr: Int
    playsound: String
    priority: Int
    reactedby: String
    reactedtime: datetime
    reactionid: Int
    reactiontype: Int
    receivedlevel: Int
    receivedtime: datetime
    receivername: String
    receivernr: Int
    relationid: Int
    repeated: String
    retranslator: Int
    retranslatorlevel: Int
    selectable: Int
    status: Int
    unifier_id: Int
    zonenumber: String
}

"aggregate min on columns"
type monas_events_min_fields {
    ObjectName: String
    Remind: String
    RemindAtTime: datetime
    RemindFromTime: datetime
    RemindInHours: Int
    RemindInMinutes: Int
    Reminder: String
    action: Int
    addedtoarchivetime: datetime
    clasificator: String
    closedby: String
    eventcode: String
    eventdescid: Int
    eventname: String
    eventsource: Int
    groupnr: Int
    id: Int
    linename: String
    linenr: Int
    lockedby: Int
    objectdbid: Int
    objectnr: Int
    playsound: String
    priority: Int
    reactedby: String
    reactedtime: datetime
    reactionid: Int
    reactiontype: Int
    receivedlevel: Int
    receivedtime: datetime
    receivername: String
    receivernr: Int
    relationid: Int
    repeated: String
    retranslator: Int
    retranslatorlevel: Int
    selectable: Int
    status: Int
    unifier_id: Int
    zonenumber: String
}

"response of any mutation on the table \"events\""
type monas_events_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [monas_events!]!
}

"aggregate stddev on columns"
type monas_events_stddev_fields {
    RemindInHours: Float
    RemindInMinutes: Float
    action: Float
    eventdescid: Float
    eventsource: Float
    groupnr: Float
    id: Float
    linenr: Float
    lockedby: Float
    objectdbid: Float
    objectnr: Float
    priority: Float
    reactionid: Float
    reactiontype: Float
    receivedlevel: Float
    receivernr: Float
    relationid: Float
    retranslator: Float
    retranslatorlevel: Float
    selectable: Float
    status: Float
    unifier_id: Float
}

"aggregate stddev_pop on columns"
type monas_events_stddev_pop_fields {
    RemindInHours: Float
    RemindInMinutes: Float
    action: Float
    eventdescid: Float
    eventsource: Float
    groupnr: Float
    id: Float
    linenr: Float
    lockedby: Float
    objectdbid: Float
    objectnr: Float
    priority: Float
    reactionid: Float
    reactiontype: Float
    receivedlevel: Float
    receivernr: Float
    relationid: Float
    retranslator: Float
    retranslatorlevel: Float
    selectable: Float
    status: Float
    unifier_id: Float
}

"aggregate stddev_samp on columns"
type monas_events_stddev_samp_fields {
    RemindInHours: Float
    RemindInMinutes: Float
    action: Float
    eventdescid: Float
    eventsource: Float
    groupnr: Float
    id: Float
    linenr: Float
    lockedby: Float
    objectdbid: Float
    objectnr: Float
    priority: Float
    reactionid: Float
    reactiontype: Float
    receivedlevel: Float
    receivernr: Float
    relationid: Float
    retranslator: Float
    retranslatorlevel: Float
    selectable: Float
    status: Float
    unifier_id: Float
}

"aggregate sum on columns"
type monas_events_sum_fields {
    RemindInHours: Int
    RemindInMinutes: Int
    action: Int
    eventdescid: Int
    eventsource: Int
    groupnr: Int
    id: Int
    linenr: Int
    lockedby: Int
    objectdbid: Int
    objectnr: Int
    priority: Int
    reactionid: Int
    reactiontype: Int
    receivedlevel: Int
    receivernr: Int
    relationid: Int
    retranslator: Int
    retranslatorlevel: Int
    selectable: Int
    status: Int
    unifier_id: Int
}

"aggregate var_pop on columns"
type monas_events_var_pop_fields {
    RemindInHours: Float
    RemindInMinutes: Float
    action: Float
    eventdescid: Float
    eventsource: Float
    groupnr: Float
    id: Float
    linenr: Float
    lockedby: Float
    objectdbid: Float
    objectnr: Float
    priority: Float
    reactionid: Float
    reactiontype: Float
    receivedlevel: Float
    receivernr: Float
    relationid: Float
    retranslator: Float
    retranslatorlevel: Float
    selectable: Float
    status: Float
    unifier_id: Float
}

"aggregate var_samp on columns"
type monas_events_var_samp_fields {
    RemindInHours: Float
    RemindInMinutes: Float
    action: Float
    eventdescid: Float
    eventsource: Float
    groupnr: Float
    id: Float
    linenr: Float
    lockedby: Float
    objectdbid: Float
    objectnr: Float
    priority: Float
    reactionid: Float
    reactiontype: Float
    receivedlevel: Float
    receivernr: Float
    relationid: Float
    retranslator: Float
    retranslatorlevel: Float
    selectable: Float
    status: Float
    unifier_id: Float
}

"aggregate variance on columns"
type monas_events_variance_fields {
    RemindInHours: Float
    RemindInMinutes: Float
    action: Float
    eventdescid: Float
    eventsource: Float
    groupnr: Float
    id: Float
    linenr: Float
    lockedby: Float
    objectdbid: Float
    objectnr: Float
    priority: Float
    reactionid: Float
    reactiontype: Float
    receivedlevel: Float
    receivernr: Float
    relationid: Float
    retranslator: Float
    retranslatorlevel: Float
    selectable: Float
    status: Float
    unifier_id: Float
}

"columns and relationships of \"objects\""
type monas_objects {
    AcLossDetected: datetime
    DcLossDetected: datetime
    Id: Int!
    Locked: Int!
    MainSubDisabled: String!
    MainSubDriverReactionTimes: String!
    MainSubEvents: String!
    MainSubGenerated: String!
    MainSubId: Int
    MainSubInfo: String!
    MainSubMoreNotes: String!
    MainSubOpenClose: String!
    MainSubPersons: String!
    MainSubSchemes: String!
    MainSubTest: String!
    MainSubZones: String!
    NotesText: varbinary
    OpenCloseSeekState: Int
    TS: timestamp
    address: String
    assignedeventexampleid: Int
    assignedgroupableeventexampleid: Int
    celebrationsclosehour: Int!
    celebrationsclosemin: Int!
    celebrationsopenhour: Int!
    celebrationsopenmin: Int!
    city: Int
    closedeviation: Int!
    closedeviationneg: Int!
    closehourdefault: Int!
    closemindefault: Int!
    contract: String
    contract2: String
    destination: Int!
    dynamic: Boolean!
    firsttest: time!
    freeEvents: Int
    fridayclosehour: Int!
    fridayclosemin: Int!
    fridayopenhour: Int!
    fridayopenmin: Int!
    generatedeventsexample: Int
    grg_info: String
    groupid: Int!
    hasura_object: object
    installed: String
    installer: Int
    installerCompany: Int
    intlinenr: Int
    intreceivernr: Int
    lastPersonToOpenClose: Int
    lasttesttime: datetime2
    latitude: Float
    linenr: String!
    longitude: Float
    mainsubgroup: String!
    mondayclosehour: Int!
    mondayclosemin: Int!
    mondayopenhour: Int!
    mondayopenmin: Int!
    mustopen: String!
    name: String
    notes: String
    obdindx: String
    objectid: Int!
    objectstate: Int!
    objectstatus: Int!
    opendeviation: Int!
    opendeviationneg: Int!
    openhourdefault: Int!
    openmindefault: Int!
    otherevents: String!
    phone: String
    reacttoeachevent: Int!
    receivernr: String!
    region: Int
    relationId: Int
    saturdayclosehour: Int!
    saturdayclosemin: Int!
    saturdayopenhour: Int!
    saturdayopenmin: Int!
    seekcelebrationsclose: String!
    seekcelebrationsopen: String!
    seekcloseworktime: String!
    seekfridayclose: String!
    seekfridayopen: String!
    seekmondayclose: String!
    seekmondayopen: String!
    seekopenworktime: String!
    seeksaturdayclose: String!
    seeksaturdayopen: String!
    seeksundayclose: String!
    seeksundayopen: String!
    seekthursdayclose: String!
    seekthursdayopen: String!
    seektuesdayclose: String!
    seektuesdayopen: String!
    seekwednesdayclose: String!
    seekwednesdayopen: String!
    specialcelebrations: String!
    specialfriday: String!
    specialmonday: String!
    specialsaturday: String!
    specialsunday: String!
    specialthursday: String!
    specialtuesday: String!
    specialwednesday: String!
    street: Int
    subdivision: Int
    subgroup: Int!
    sundayclosehour: Int!
    sundayclosemin: Int!
    sundayopenhour: Int!
    sundayopenmin: Int!
    synchronize: Boolean!
    testtype: Int!
    thursdayclosehour: Int!
    thursdayclosemin: Int!
    thursdayopenhour: Int!
    thursdayopenmin: Int!
    timebetweentestdays: Int!
    timebetweentesttime: time!
    timesperday: Int!
    timestamp: datetime!
    tolerance: Int!
    transinstdate: String
    tuesdayclosehour: Int!
    tuesdayclosemin: Int!
    tuesdayopenhour: Int!
    tuesdayopenmin: Int!
    unifier_id: Int
    uniqueID: uniqueidentifier!
    useeventexample: String!
    usegroupableeventsexample: String!
    wednesdayclosehour: Int!
    wednesdayclosemin: Int!
    wednesdayopenhour: Int!
    wednesdayopenmin: Int!
}

"aggregated selection of \"objects\""
type monas_objects_aggregate {
    aggregate: monas_objects_aggregate_fields
    nodes: [monas_objects!]!
}

"aggregate fields of \"objects\""
type monas_objects_aggregate_fields {
    avg: monas_objects_avg_fields
    count(column: monas_objects_select_column, distinct: Boolean): Int!
    max: monas_objects_max_fields
    min: monas_objects_min_fields
    stddev: monas_objects_stddev_fields
    stddev_pop: monas_objects_stddev_pop_fields
    stddev_samp: monas_objects_stddev_samp_fields
    sum: monas_objects_sum_fields
    var_pop: monas_objects_var_pop_fields
    var_samp: monas_objects_var_samp_fields
    variance: monas_objects_variance_fields
}

"aggregate avg on columns"
type monas_objects_avg_fields {
    Id: Float
    Locked: Float
    MainSubId: Float
    OpenCloseSeekState: Float
    assignedeventexampleid: Float
    assignedgroupableeventexampleid: Float
    celebrationsclosehour: Float
    celebrationsclosemin: Float
    celebrationsopenhour: Float
    celebrationsopenmin: Float
    city: Float
    closedeviation: Float
    closedeviationneg: Float
    closehourdefault: Float
    closemindefault: Float
    destination: Float
    freeEvents: Float
    fridayclosehour: Float
    fridayclosemin: Float
    fridayopenhour: Float
    fridayopenmin: Float
    generatedeventsexample: Float
    groupid: Float
    installer: Float
    installerCompany: Float
    intlinenr: Float
    intreceivernr: Float
    lastPersonToOpenClose: Float
    latitude: Float
    longitude: Float
    mondayclosehour: Float
    mondayclosemin: Float
    mondayopenhour: Float
    mondayopenmin: Float
    objectid: Float
    objectstate: Float
    objectstatus: Float
    opendeviation: Float
    opendeviationneg: Float
    openhourdefault: Float
    openmindefault: Float
    reacttoeachevent: Float
    region: Float
    relationId: Float
    saturdayclosehour: Float
    saturdayclosemin: Float
    saturdayopenhour: Float
    saturdayopenmin: Float
    street: Float
    subdivision: Float
    subgroup: Float
    sundayclosehour: Float
    sundayclosemin: Float
    sundayopenhour: Float
    sundayopenmin: Float
    testtype: Float
    thursdayclosehour: Float
    thursdayclosemin: Float
    thursdayopenhour: Float
    thursdayopenmin: Float
    timebetweentestdays: Float
    timesperday: Float
    tolerance: Float
    tuesdayclosehour: Float
    tuesdayclosemin: Float
    tuesdayopenhour: Float
    tuesdayopenmin: Float
    unifier_id: Float
    wednesdayclosehour: Float
    wednesdayclosemin: Float
    wednesdayopenhour: Float
    wednesdayopenmin: Float
}

"aggregate max on columns"
type monas_objects_max_fields {
    AcLossDetected: datetime
    DcLossDetected: datetime
    Id: Int
    Locked: Int
    MainSubDisabled: String
    MainSubDriverReactionTimes: String
    MainSubEvents: String
    MainSubGenerated: String
    MainSubId: Int
    MainSubInfo: String
    MainSubMoreNotes: String
    MainSubOpenClose: String
    MainSubPersons: String
    MainSubSchemes: String
    MainSubTest: String
    MainSubZones: String
    OpenCloseSeekState: Int
    TS: timestamp
    address: String
    assignedeventexampleid: Int
    assignedgroupableeventexampleid: Int
    celebrationsclosehour: Int
    celebrationsclosemin: Int
    celebrationsopenhour: Int
    celebrationsopenmin: Int
    city: Int
    closedeviation: Int
    closedeviationneg: Int
    closehourdefault: Int
    closemindefault: Int
    contract: String
    contract2: String
    destination: Int
    firsttest: time
    freeEvents: Int
    fridayclosehour: Int
    fridayclosemin: Int
    fridayopenhour: Int
    fridayopenmin: Int
    generatedeventsexample: Int
    grg_info: String
    groupid: Int
    installed: String
    installer: Int
    installerCompany: Int
    intlinenr: Int
    intreceivernr: Int
    lastPersonToOpenClose: Int
    lasttesttime: datetime2
    latitude: Float
    linenr: String
    longitude: Float
    mainsubgroup: String
    mondayclosehour: Int
    mondayclosemin: Int
    mondayopenhour: Int
    mondayopenmin: Int
    mustopen: String
    name: String
    notes: String
    obdindx: String
    objectid: Int
    objectstate: Int
    objectstatus: Int
    opendeviation: Int
    opendeviationneg: Int
    openhourdefault: Int
    openmindefault: Int
    otherevents: String
    phone: String
    reacttoeachevent: Int
    receivernr: String
    region: Int
    relationId: Int
    saturdayclosehour: Int
    saturdayclosemin: Int
    saturdayopenhour: Int
    saturdayopenmin: Int
    seekcelebrationsclose: String
    seekcelebrationsopen: String
    seekcloseworktime: String
    seekfridayclose: String
    seekfridayopen: String
    seekmondayclose: String
    seekmondayopen: String
    seekopenworktime: String
    seeksaturdayclose: String
    seeksaturdayopen: String
    seeksundayclose: String
    seeksundayopen: String
    seekthursdayclose: String
    seekthursdayopen: String
    seektuesdayclose: String
    seektuesdayopen: String
    seekwednesdayclose: String
    seekwednesdayopen: String
    specialcelebrations: String
    specialfriday: String
    specialmonday: String
    specialsaturday: String
    specialsunday: String
    specialthursday: String
    specialtuesday: String
    specialwednesday: String
    street: Int
    subdivision: Int
    subgroup: Int
    sundayclosehour: Int
    sundayclosemin: Int
    sundayopenhour: Int
    sundayopenmin: Int
    testtype: Int
    thursdayclosehour: Int
    thursdayclosemin: Int
    thursdayopenhour: Int
    thursdayopenmin: Int
    timebetweentestdays: Int
    timebetweentesttime: time
    timesperday: Int
    timestamp: datetime
    tolerance: Int
    transinstdate: String
    tuesdayclosehour: Int
    tuesdayclosemin: Int
    tuesdayopenhour: Int
    tuesdayopenmin: Int
    unifier_id: Int
    useeventexample: String
    usegroupableeventsexample: String
    wednesdayclosehour: Int
    wednesdayclosemin: Int
    wednesdayopenhour: Int
    wednesdayopenmin: Int
}

"aggregate min on columns"
type monas_objects_min_fields {
    AcLossDetected: datetime
    DcLossDetected: datetime
    Id: Int
    Locked: Int
    MainSubDisabled: String
    MainSubDriverReactionTimes: String
    MainSubEvents: String
    MainSubGenerated: String
    MainSubId: Int
    MainSubInfo: String
    MainSubMoreNotes: String
    MainSubOpenClose: String
    MainSubPersons: String
    MainSubSchemes: String
    MainSubTest: String
    MainSubZones: String
    OpenCloseSeekState: Int
    TS: timestamp
    address: String
    assignedeventexampleid: Int
    assignedgroupableeventexampleid: Int
    celebrationsclosehour: Int
    celebrationsclosemin: Int
    celebrationsopenhour: Int
    celebrationsopenmin: Int
    city: Int
    closedeviation: Int
    closedeviationneg: Int
    closehourdefault: Int
    closemindefault: Int
    contract: String
    contract2: String
    destination: Int
    firsttest: time
    freeEvents: Int
    fridayclosehour: Int
    fridayclosemin: Int
    fridayopenhour: Int
    fridayopenmin: Int
    generatedeventsexample: Int
    grg_info: String
    groupid: Int
    installed: String
    installer: Int
    installerCompany: Int
    intlinenr: Int
    intreceivernr: Int
    lastPersonToOpenClose: Int
    lasttesttime: datetime2
    latitude: Float
    linenr: String
    longitude: Float
    mainsubgroup: String
    mondayclosehour: Int
    mondayclosemin: Int
    mondayopenhour: Int
    mondayopenmin: Int
    mustopen: String
    name: String
    notes: String
    obdindx: String
    objectid: Int
    objectstate: Int
    objectstatus: Int
    opendeviation: Int
    opendeviationneg: Int
    openhourdefault: Int
    openmindefault: Int
    otherevents: String
    phone: String
    reacttoeachevent: Int
    receivernr: String
    region: Int
    relationId: Int
    saturdayclosehour: Int
    saturdayclosemin: Int
    saturdayopenhour: Int
    saturdayopenmin: Int
    seekcelebrationsclose: String
    seekcelebrationsopen: String
    seekcloseworktime: String
    seekfridayclose: String
    seekfridayopen: String
    seekmondayclose: String
    seekmondayopen: String
    seekopenworktime: String
    seeksaturdayclose: String
    seeksaturdayopen: String
    seeksundayclose: String
    seeksundayopen: String
    seekthursdayclose: String
    seekthursdayopen: String
    seektuesdayclose: String
    seektuesdayopen: String
    seekwednesdayclose: String
    seekwednesdayopen: String
    specialcelebrations: String
    specialfriday: String
    specialmonday: String
    specialsaturday: String
    specialsunday: String
    specialthursday: String
    specialtuesday: String
    specialwednesday: String
    street: Int
    subdivision: Int
    subgroup: Int
    sundayclosehour: Int
    sundayclosemin: Int
    sundayopenhour: Int
    sundayopenmin: Int
    testtype: Int
    thursdayclosehour: Int
    thursdayclosemin: Int
    thursdayopenhour: Int
    thursdayopenmin: Int
    timebetweentestdays: Int
    timebetweentesttime: time
    timesperday: Int
    timestamp: datetime
    tolerance: Int
    transinstdate: String
    tuesdayclosehour: Int
    tuesdayclosemin: Int
    tuesdayopenhour: Int
    tuesdayopenmin: Int
    unifier_id: Int
    useeventexample: String
    usegroupableeventsexample: String
    wednesdayclosehour: Int
    wednesdayclosemin: Int
    wednesdayopenhour: Int
    wednesdayopenmin: Int
}

"response of any mutation on the table \"objects\""
type monas_objects_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [monas_objects!]!
}

"aggregate stddev on columns"
type monas_objects_stddev_fields {
    Id: Float
    Locked: Float
    MainSubId: Float
    OpenCloseSeekState: Float
    assignedeventexampleid: Float
    assignedgroupableeventexampleid: Float
    celebrationsclosehour: Float
    celebrationsclosemin: Float
    celebrationsopenhour: Float
    celebrationsopenmin: Float
    city: Float
    closedeviation: Float
    closedeviationneg: Float
    closehourdefault: Float
    closemindefault: Float
    destination: Float
    freeEvents: Float
    fridayclosehour: Float
    fridayclosemin: Float
    fridayopenhour: Float
    fridayopenmin: Float
    generatedeventsexample: Float
    groupid: Float
    installer: Float
    installerCompany: Float
    intlinenr: Float
    intreceivernr: Float
    lastPersonToOpenClose: Float
    latitude: Float
    longitude: Float
    mondayclosehour: Float
    mondayclosemin: Float
    mondayopenhour: Float
    mondayopenmin: Float
    objectid: Float
    objectstate: Float
    objectstatus: Float
    opendeviation: Float
    opendeviationneg: Float
    openhourdefault: Float
    openmindefault: Float
    reacttoeachevent: Float
    region: Float
    relationId: Float
    saturdayclosehour: Float
    saturdayclosemin: Float
    saturdayopenhour: Float
    saturdayopenmin: Float
    street: Float
    subdivision: Float
    subgroup: Float
    sundayclosehour: Float
    sundayclosemin: Float
    sundayopenhour: Float
    sundayopenmin: Float
    testtype: Float
    thursdayclosehour: Float
    thursdayclosemin: Float
    thursdayopenhour: Float
    thursdayopenmin: Float
    timebetweentestdays: Float
    timesperday: Float
    tolerance: Float
    tuesdayclosehour: Float
    tuesdayclosemin: Float
    tuesdayopenhour: Float
    tuesdayopenmin: Float
    unifier_id: Float
    wednesdayclosehour: Float
    wednesdayclosemin: Float
    wednesdayopenhour: Float
    wednesdayopenmin: Float
}

"aggregate stddev_pop on columns"
type monas_objects_stddev_pop_fields {
    Id: Float
    Locked: Float
    MainSubId: Float
    OpenCloseSeekState: Float
    assignedeventexampleid: Float
    assignedgroupableeventexampleid: Float
    celebrationsclosehour: Float
    celebrationsclosemin: Float
    celebrationsopenhour: Float
    celebrationsopenmin: Float
    city: Float
    closedeviation: Float
    closedeviationneg: Float
    closehourdefault: Float
    closemindefault: Float
    destination: Float
    freeEvents: Float
    fridayclosehour: Float
    fridayclosemin: Float
    fridayopenhour: Float
    fridayopenmin: Float
    generatedeventsexample: Float
    groupid: Float
    installer: Float
    installerCompany: Float
    intlinenr: Float
    intreceivernr: Float
    lastPersonToOpenClose: Float
    latitude: Float
    longitude: Float
    mondayclosehour: Float
    mondayclosemin: Float
    mondayopenhour: Float
    mondayopenmin: Float
    objectid: Float
    objectstate: Float
    objectstatus: Float
    opendeviation: Float
    opendeviationneg: Float
    openhourdefault: Float
    openmindefault: Float
    reacttoeachevent: Float
    region: Float
    relationId: Float
    saturdayclosehour: Float
    saturdayclosemin: Float
    saturdayopenhour: Float
    saturdayopenmin: Float
    street: Float
    subdivision: Float
    subgroup: Float
    sundayclosehour: Float
    sundayclosemin: Float
    sundayopenhour: Float
    sundayopenmin: Float
    testtype: Float
    thursdayclosehour: Float
    thursdayclosemin: Float
    thursdayopenhour: Float
    thursdayopenmin: Float
    timebetweentestdays: Float
    timesperday: Float
    tolerance: Float
    tuesdayclosehour: Float
    tuesdayclosemin: Float
    tuesdayopenhour: Float
    tuesdayopenmin: Float
    unifier_id: Float
    wednesdayclosehour: Float
    wednesdayclosemin: Float
    wednesdayopenhour: Float
    wednesdayopenmin: Float
}

"aggregate stddev_samp on columns"
type monas_objects_stddev_samp_fields {
    Id: Float
    Locked: Float
    MainSubId: Float
    OpenCloseSeekState: Float
    assignedeventexampleid: Float
    assignedgroupableeventexampleid: Float
    celebrationsclosehour: Float
    celebrationsclosemin: Float
    celebrationsopenhour: Float
    celebrationsopenmin: Float
    city: Float
    closedeviation: Float
    closedeviationneg: Float
    closehourdefault: Float
    closemindefault: Float
    destination: Float
    freeEvents: Float
    fridayclosehour: Float
    fridayclosemin: Float
    fridayopenhour: Float
    fridayopenmin: Float
    generatedeventsexample: Float
    groupid: Float
    installer: Float
    installerCompany: Float
    intlinenr: Float
    intreceivernr: Float
    lastPersonToOpenClose: Float
    latitude: Float
    longitude: Float
    mondayclosehour: Float
    mondayclosemin: Float
    mondayopenhour: Float
    mondayopenmin: Float
    objectid: Float
    objectstate: Float
    objectstatus: Float
    opendeviation: Float
    opendeviationneg: Float
    openhourdefault: Float
    openmindefault: Float
    reacttoeachevent: Float
    region: Float
    relationId: Float
    saturdayclosehour: Float
    saturdayclosemin: Float
    saturdayopenhour: Float
    saturdayopenmin: Float
    street: Float
    subdivision: Float
    subgroup: Float
    sundayclosehour: Float
    sundayclosemin: Float
    sundayopenhour: Float
    sundayopenmin: Float
    testtype: Float
    thursdayclosehour: Float
    thursdayclosemin: Float
    thursdayopenhour: Float
    thursdayopenmin: Float
    timebetweentestdays: Float
    timesperday: Float
    tolerance: Float
    tuesdayclosehour: Float
    tuesdayclosemin: Float
    tuesdayopenhour: Float
    tuesdayopenmin: Float
    unifier_id: Float
    wednesdayclosehour: Float
    wednesdayclosemin: Float
    wednesdayopenhour: Float
    wednesdayopenmin: Float
}

"aggregate sum on columns"
type monas_objects_sum_fields {
    Id: Int
    Locked: Int
    MainSubId: Int
    OpenCloseSeekState: Int
    assignedeventexampleid: Int
    assignedgroupableeventexampleid: Int
    celebrationsclosehour: Int
    celebrationsclosemin: Int
    celebrationsopenhour: Int
    celebrationsopenmin: Int
    city: Int
    closedeviation: Int
    closedeviationneg: Int
    closehourdefault: Int
    closemindefault: Int
    destination: Int
    freeEvents: Int
    fridayclosehour: Int
    fridayclosemin: Int
    fridayopenhour: Int
    fridayopenmin: Int
    generatedeventsexample: Int
    groupid: Int
    installer: Int
    installerCompany: Int
    intlinenr: Int
    intreceivernr: Int
    lastPersonToOpenClose: Int
    latitude: Float
    longitude: Float
    mondayclosehour: Int
    mondayclosemin: Int
    mondayopenhour: Int
    mondayopenmin: Int
    objectid: Int
    objectstate: Int
    objectstatus: Int
    opendeviation: Int
    opendeviationneg: Int
    openhourdefault: Int
    openmindefault: Int
    reacttoeachevent: Int
    region: Int
    relationId: Int
    saturdayclosehour: Int
    saturdayclosemin: Int
    saturdayopenhour: Int
    saturdayopenmin: Int
    street: Int
    subdivision: Int
    subgroup: Int
    sundayclosehour: Int
    sundayclosemin: Int
    sundayopenhour: Int
    sundayopenmin: Int
    testtype: Int
    thursdayclosehour: Int
    thursdayclosemin: Int
    thursdayopenhour: Int
    thursdayopenmin: Int
    timebetweentestdays: Int
    timesperday: Int
    tolerance: Int
    tuesdayclosehour: Int
    tuesdayclosemin: Int
    tuesdayopenhour: Int
    tuesdayopenmin: Int
    unifier_id: Int
    wednesdayclosehour: Int
    wednesdayclosemin: Int
    wednesdayopenhour: Int
    wednesdayopenmin: Int
}

"aggregate var_pop on columns"
type monas_objects_var_pop_fields {
    Id: Float
    Locked: Float
    MainSubId: Float
    OpenCloseSeekState: Float
    assignedeventexampleid: Float
    assignedgroupableeventexampleid: Float
    celebrationsclosehour: Float
    celebrationsclosemin: Float
    celebrationsopenhour: Float
    celebrationsopenmin: Float
    city: Float
    closedeviation: Float
    closedeviationneg: Float
    closehourdefault: Float
    closemindefault: Float
    destination: Float
    freeEvents: Float
    fridayclosehour: Float
    fridayclosemin: Float
    fridayopenhour: Float
    fridayopenmin: Float
    generatedeventsexample: Float
    groupid: Float
    installer: Float
    installerCompany: Float
    intlinenr: Float
    intreceivernr: Float
    lastPersonToOpenClose: Float
    latitude: Float
    longitude: Float
    mondayclosehour: Float
    mondayclosemin: Float
    mondayopenhour: Float
    mondayopenmin: Float
    objectid: Float
    objectstate: Float
    objectstatus: Float
    opendeviation: Float
    opendeviationneg: Float
    openhourdefault: Float
    openmindefault: Float
    reacttoeachevent: Float
    region: Float
    relationId: Float
    saturdayclosehour: Float
    saturdayclosemin: Float
    saturdayopenhour: Float
    saturdayopenmin: Float
    street: Float
    subdivision: Float
    subgroup: Float
    sundayclosehour: Float
    sundayclosemin: Float
    sundayopenhour: Float
    sundayopenmin: Float
    testtype: Float
    thursdayclosehour: Float
    thursdayclosemin: Float
    thursdayopenhour: Float
    thursdayopenmin: Float
    timebetweentestdays: Float
    timesperday: Float
    tolerance: Float
    tuesdayclosehour: Float
    tuesdayclosemin: Float
    tuesdayopenhour: Float
    tuesdayopenmin: Float
    unifier_id: Float
    wednesdayclosehour: Float
    wednesdayclosemin: Float
    wednesdayopenhour: Float
    wednesdayopenmin: Float
}

"aggregate var_samp on columns"
type monas_objects_var_samp_fields {
    Id: Float
    Locked: Float
    MainSubId: Float
    OpenCloseSeekState: Float
    assignedeventexampleid: Float
    assignedgroupableeventexampleid: Float
    celebrationsclosehour: Float
    celebrationsclosemin: Float
    celebrationsopenhour: Float
    celebrationsopenmin: Float
    city: Float
    closedeviation: Float
    closedeviationneg: Float
    closehourdefault: Float
    closemindefault: Float
    destination: Float
    freeEvents: Float
    fridayclosehour: Float
    fridayclosemin: Float
    fridayopenhour: Float
    fridayopenmin: Float
    generatedeventsexample: Float
    groupid: Float
    installer: Float
    installerCompany: Float
    intlinenr: Float
    intreceivernr: Float
    lastPersonToOpenClose: Float
    latitude: Float
    longitude: Float
    mondayclosehour: Float
    mondayclosemin: Float
    mondayopenhour: Float
    mondayopenmin: Float
    objectid: Float
    objectstate: Float
    objectstatus: Float
    opendeviation: Float
    opendeviationneg: Float
    openhourdefault: Float
    openmindefault: Float
    reacttoeachevent: Float
    region: Float
    relationId: Float
    saturdayclosehour: Float
    saturdayclosemin: Float
    saturdayopenhour: Float
    saturdayopenmin: Float
    street: Float
    subdivision: Float
    subgroup: Float
    sundayclosehour: Float
    sundayclosemin: Float
    sundayopenhour: Float
    sundayopenmin: Float
    testtype: Float
    thursdayclosehour: Float
    thursdayclosemin: Float
    thursdayopenhour: Float
    thursdayopenmin: Float
    timebetweentestdays: Float
    timesperday: Float
    tolerance: Float
    tuesdayclosehour: Float
    tuesdayclosemin: Float
    tuesdayopenhour: Float
    tuesdayopenmin: Float
    unifier_id: Float
    wednesdayclosehour: Float
    wednesdayclosemin: Float
    wednesdayopenhour: Float
    wednesdayopenmin: Float
}

"aggregate variance on columns"
type monas_objects_variance_fields {
    Id: Float
    Locked: Float
    MainSubId: Float
    OpenCloseSeekState: Float
    assignedeventexampleid: Float
    assignedgroupableeventexampleid: Float
    celebrationsclosehour: Float
    celebrationsclosemin: Float
    celebrationsopenhour: Float
    celebrationsopenmin: Float
    city: Float
    closedeviation: Float
    closedeviationneg: Float
    closehourdefault: Float
    closemindefault: Float
    destination: Float
    freeEvents: Float
    fridayclosehour: Float
    fridayclosemin: Float
    fridayopenhour: Float
    fridayopenmin: Float
    generatedeventsexample: Float
    groupid: Float
    installer: Float
    installerCompany: Float
    intlinenr: Float
    intreceivernr: Float
    lastPersonToOpenClose: Float
    latitude: Float
    longitude: Float
    mondayclosehour: Float
    mondayclosemin: Float
    mondayopenhour: Float
    mondayopenmin: Float
    objectid: Float
    objectstate: Float
    objectstatus: Float
    opendeviation: Float
    opendeviationneg: Float
    openhourdefault: Float
    openmindefault: Float
    reacttoeachevent: Float
    region: Float
    relationId: Float
    saturdayclosehour: Float
    saturdayclosemin: Float
    saturdayopenhour: Float
    saturdayopenmin: Float
    street: Float
    subdivision: Float
    subgroup: Float
    sundayclosehour: Float
    sundayclosemin: Float
    sundayopenhour: Float
    sundayopenmin: Float
    testtype: Float
    thursdayclosehour: Float
    thursdayclosemin: Float
    thursdayopenhour: Float
    thursdayopenmin: Float
    timebetweentestdays: Float
    timesperday: Float
    tolerance: Float
    tuesdayclosehour: Float
    tuesdayclosemin: Float
    tuesdayopenhour: Float
    tuesdayopenmin: Float
    unifier_id: Float
    wednesdayclosehour: Float
    wednesdayclosemin: Float
    wednesdayopenhour: Float
    wednesdayopenmin: Float
}

"columns and relationships of \"monas_related\""
type monas_related {
    Id: String
    area_no: String
    assign_car: String
    atm: String
    contact: String
    id: uuid!
    image: String
    imagename: String
    modem: String
    monasid: Int
    navid: Int
    object_contract: String
    object_key: String
    send_crew: Boolean!
}

"aggregated selection of \"monas_related\""
type monas_related_aggregate {
    aggregate: monas_related_aggregate_fields
    nodes: [monas_related!]!
}

"aggregate fields of \"monas_related\""
type monas_related_aggregate_fields {
    avg: monas_related_avg_fields
    count(columns: [monas_related_select_column!], distinct: Boolean): Int!
    max: monas_related_max_fields
    min: monas_related_min_fields
    stddev: monas_related_stddev_fields
    stddev_pop: monas_related_stddev_pop_fields
    stddev_samp: monas_related_stddev_samp_fields
    sum: monas_related_sum_fields
    var_pop: monas_related_var_pop_fields
    var_samp: monas_related_var_samp_fields
    variance: monas_related_variance_fields
}

"aggregate avg on columns"
type monas_related_avg_fields {
    monasid: Float
    navid: Float
}

"aggregate max on columns"
type monas_related_max_fields {
    Id: String
    area_no: String
    assign_car: String
    atm: String
    contact: String
    id: uuid
    image: String
    imagename: String
    modem: String
    monasid: Int
    navid: Int
    object_contract: String
    object_key: String
}

"aggregate min on columns"
type monas_related_min_fields {
    Id: String
    area_no: String
    assign_car: String
    atm: String
    contact: String
    id: uuid
    image: String
    imagename: String
    modem: String
    monasid: Int
    navid: Int
    object_contract: String
    object_key: String
}

"response of any mutation on the table \"monas_related\""
type monas_related_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [monas_related!]!
}

"aggregate stddev on columns"
type monas_related_stddev_fields {
    monasid: Float
    navid: Float
}

"aggregate stddev_pop on columns"
type monas_related_stddev_pop_fields {
    monasid: Float
    navid: Float
}

"aggregate stddev_samp on columns"
type monas_related_stddev_samp_fields {
    monasid: Float
    navid: Float
}

"aggregate sum on columns"
type monas_related_sum_fields {
    monasid: Int
    navid: Int
}

"aggregate var_pop on columns"
type monas_related_var_pop_fields {
    monasid: Float
    navid: Float
}

"aggregate var_samp on columns"
type monas_related_var_samp_fields {
    monasid: Float
    navid: Float
}

"aggregate variance on columns"
type monas_related_variance_fields {
    monasid: Float
    navid: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"central\""
    delete_central(
        "filter the rows which have to be deleted"
        where: central_bool_exp!
    ): central_mutation_response
    "delete single row from the table: \"central\""
    delete_central_by_pk(value: String!): central
    "delete data from the table: \"city\""
    delete_city(
        "filter the rows which have to be deleted"
        where: city_bool_exp!
    ): city_mutation_response
    "delete single row from the table: \"city\""
    delete_city_by_pk(value: String!): city
    "delete data from the table: \"coresppersons\""
    delete_coresppersons(
        "filter the rows which have to be deleted"
        where: coresppersons_bool_exp!
    ): coresppersons_mutation_response
    "delete single row from the table: \"coresppersons\""
    delete_coresppersons_by_pk(id: String!): coresppersons
    "delete data from the table: \"corresppersons\""
    delete_corresppersons(
        "filter the rows which have to be deleted"
        where: corresppersons_bool_exp!
    ): corresppersons_mutation_response
    "delete single row from the table: \"corresppersons\""
    delete_corresppersons_by_pk(id: Int!): corresppersons
    "delete data from the table: \"crew\""
    delete_crew(
        "filter the rows which have to be deleted"
        where: crew_bool_exp!
    ): crew_mutation_response
    "delete data from the table: \"crew_breach\""
    delete_crew_breach(
        "filter the rows which have to be deleted"
        where: crew_breach_bool_exp!
    ): crew_breach_mutation_response
    "delete single row from the table: \"crew_breach\""
    delete_crew_breach_by_pk(id: uuid!): crew_breach
    "delete single row from the table: \"crew\""
    delete_crew_by_pk(id: uuid!): crew
    "delete data from the table: \"crew_calendar\""
    delete_crew_calendar(
        "filter the rows which have to be deleted"
        where: crew_calendar_bool_exp!
    ): crew_calendar_mutation_response
    "delete single row from the table: \"crew_calendar\""
    delete_crew_calendar_by_pk(id: uuid!): crew_calendar
    "delete data from the table: \"crew_driver\""
    delete_crew_driver(
        "filter the rows which have to be deleted"
        where: crew_driver_bool_exp!
    ): crew_driver_mutation_response
    "delete single row from the table: \"crew_driver\""
    delete_crew_driver_by_pk(id: uuid!): crew_driver
    "delete data from the table: \"crew_permission\""
    delete_crew_permission(
        "filter the rows which have to be deleted"
        where: crew_permission_bool_exp!
    ): crew_permission_mutation_response
    "delete single row from the table: \"crew_permission\""
    delete_crew_permission_by_pk(id: uuid!): crew_permission
    "delete data from the table: \"crew_request\""
    delete_crew_request(
        "filter the rows which have to be deleted"
        where: crew_request_bool_exp!
    ): crew_request_mutation_response
    "delete single row from the table: \"crew_request\""
    delete_crew_request_by_pk(value: String!): crew_request
    "delete data from the table: \"crew_request_status\""
    delete_crew_request_status(
        "filter the rows which have to be deleted"
        where: crew_request_status_bool_exp!
    ): crew_request_status_mutation_response
    "delete single row from the table: \"crew_request_status\""
    delete_crew_request_status_by_pk(value: String!): crew_request_status
    "delete data from the table: \"crew_status\""
    delete_crew_status(
        "filter the rows which have to be deleted"
        where: crew_status_bool_exp!
    ): crew_status_mutation_response
    "delete single row from the table: \"crew_status\""
    delete_crew_status_by_pk(value: String!): crew_status
    "delete data from the table: \"crew_zone\""
    delete_crew_zone(
        "filter the rows which have to be deleted"
        where: crew_zone_bool_exp!
    ): crew_zone_mutation_response
    "delete single row from the table: \"crew_zone\""
    delete_crew_zone_by_pk(id: uuid!): crew_zone
    "delete data from the table: \"event_status\""
    delete_event_status(
        "filter the rows which have to be deleted"
        where: event_status_bool_exp!
    ): event_status_mutation_response
    "delete single row from the table: \"event_status\""
    delete_event_status_by_pk(value: String!): event_status
    "delete data from the table: \"events\""
    delete_events(
        "filter the rows which have to be deleted"
        where: events_bool_exp!
    ): events_mutation_response
    "delete single row from the table: \"events\""
    delete_events_by_pk(id: uuid!): events
    "delete data from the table: \"eventsdescription\""
    delete_eventsdescription(
        "filter the rows which have to be deleted"
        where: eventsdescription_bool_exp!
    ): eventsdescription_mutation_response
    "delete single row from the table: \"eventsdescription\""
    delete_eventsdescription_by_pk(Id: Int!): eventsdescription
    "delete data from the table: \"filters\""
    delete_filters(
        "filter the rows which have to be deleted"
        where: filters_bool_exp!
    ): filters_mutation_response
    "delete single row from the table: \"filters\""
    delete_filters_by_pk(Id: uuid!): filters
    "delete data from the table: \"events\""
    delete_monas_events(
        "filter the rows which have to be deleted"
        where: monas_events_bool_exp!
    ): monas_events_mutation_response
    "delete single row from the table: \"events\""
    delete_monas_events_by_pk(id: Int!): monas_events
    "delete data from the table: \"objects\""
    delete_monas_objects(
        "filter the rows which have to be deleted"
        where: monas_objects_bool_exp!
    ): monas_objects_mutation_response
    "delete single row from the table: \"objects\""
    delete_monas_objects_by_pk(Id: Int!): monas_objects
    "delete data from the table: \"monas_related\""
    delete_monas_related(
        "filter the rows which have to be deleted"
        where: monas_related_bool_exp!
    ): monas_related_mutation_response
    "delete single row from the table: \"monas_related\""
    delete_monas_related_by_pk(id: uuid!): monas_related
    "delete data from the table: \"object\""
    delete_object(
        "filter the rows which have to be deleted"
        where: object_bool_exp!
    ): object_mutation_response
    "delete single row from the table: \"object\""
    delete_object_by_pk(id: uuid!): object
    "delete data from the table: \"object_image\""
    delete_object_image(
        "filter the rows which have to be deleted"
        where: object_image_bool_exp!
    ): object_image_mutation_response
    "delete single row from the table: \"object_image\""
    delete_object_image_by_pk(id: uuid!): object_image
    "delete data from the table: \"object_key\""
    delete_object_key(
        "filter the rows which have to be deleted"
        where: object_key_bool_exp!
    ): object_key_mutation_response
    "delete data from the table: \"object_key_box\""
    delete_object_key_box(
        "filter the rows which have to be deleted"
        where: object_key_box_bool_exp!
    ): object_key_box_mutation_response
    "delete single row from the table: \"object_key_box\""
    delete_object_key_box_by_pk(id: uuid!): object_key_box
    "delete single row from the table: \"object_key\""
    delete_object_key_by_pk(id: uuid!): object_key
    "delete data from the table: \"object_key_rels\""
    delete_object_key_rels(
        "filter the rows which have to be deleted"
        where: object_key_rels_bool_exp!
    ): object_key_rels_mutation_response
    "delete single row from the table: \"object_key_rels\""
    delete_object_key_rels_by_pk(box_id: uuid!, key_id: uuid!): object_key_rels
    "delete data from the table: \"object_modem\""
    delete_object_modem(
        "filter the rows which have to be deleted"
        where: object_modem_bool_exp!
    ): object_modem_mutation_response
    "delete single row from the table: \"object_modem\""
    delete_object_modem_by_pk(id: uuid!): object_modem
    "delete data from the table: \"object_user_rel\""
    delete_object_user_rel(
        "filter the rows which have to be deleted"
        where: object_user_rel_bool_exp!
    ): object_user_rel_mutation_response
    "delete single row from the table: \"object_user_rel\""
    delete_object_user_rel_by_pk(object_id: uuid!, user_id: uuid!): object_user_rel
    "delete data from the table: \"objectimages\""
    delete_objectimages(
        "filter the rows which have to be deleted"
        where: objectimages_bool_exp!
    ): objectimages_mutation_response
    "delete single row from the table: \"objectimages\""
    delete_objectimages_by_pk(Id: Int!): objectimages
    "delete data from the table: \"provider\""
    delete_provider(
        "filter the rows which have to be deleted"
        where: provider_bool_exp!
    ): provider_mutation_response
    "delete single row from the table: \"provider\""
    delete_provider_by_pk(value: String!): provider
    "delete data from the table: \"reason_for_cancellation\""
    delete_reason_for_cancellation(
        "filter the rows which have to be deleted"
        where: reason_for_cancellation_bool_exp!
    ): reason_for_cancellation_mutation_response
    "delete single row from the table: \"reason_for_cancellation\""
    delete_reason_for_cancellation_by_pk(value: String!): reason_for_cancellation
    "delete data from the table: \"task_type\""
    delete_task_type(
        "filter the rows which have to be deleted"
        where: task_type_bool_exp!
    ): task_type_mutation_response
    "delete single row from the table: \"task_type\""
    delete_task_type_by_pk(value: String!): task_type
    "delete data from the table: \"user_settings\""
    delete_user_settings(
        "filter the rows which have to be deleted"
        where: user_settings_bool_exp!
    ): user_settings_mutation_response
    "delete single row from the table: \"user_settings\""
    delete_user_settings_by_pk(id: Int!): user_settings
    "delete data from the table: \"user_type\""
    delete_user_type(
        "filter the rows which have to be deleted"
        where: user_type_bool_exp!
    ): user_type_mutation_response
    "delete single row from the table: \"user_type\""
    delete_user_type_by_pk(value: String!): user_type
    "insert data into the table: \"central\""
    insert_central(
        "the rows to be inserted"
        objects: [central_insert_input!]!,
        "upsert condition"
        on_conflict: central_on_conflict
    ): central_mutation_response
    "insert a single row into the table: \"central\""
    insert_central_one(
        "the row to be inserted"
        object: central_insert_input!,
        "upsert condition"
        on_conflict: central_on_conflict
    ): central
    "insert data into the table: \"city\""
    insert_city(
        "the rows to be inserted"
        objects: [city_insert_input!]!,
        "upsert condition"
        on_conflict: city_on_conflict
    ): city_mutation_response
    "insert a single row into the table: \"city\""
    insert_city_one(
        "the row to be inserted"
        object: city_insert_input!,
        "upsert condition"
        on_conflict: city_on_conflict
    ): city
    "insert data into the table: \"coresppersons\""
    insert_coresppersons(
        "the rows to be inserted"
        objects: [coresppersons_insert_input!]!,
        "upsert condition"
        on_conflict: coresppersons_on_conflict
    ): coresppersons_mutation_response
    "insert a single row into the table: \"coresppersons\""
    insert_coresppersons_one(
        "the row to be inserted"
        object: coresppersons_insert_input!,
        "upsert condition"
        on_conflict: coresppersons_on_conflict
    ): coresppersons
    "insert data into the table: \"corresppersons\""
    insert_corresppersons(
        "upsert condition"
        if_matched: corresppersons_if_matched,
        "the rows to be inserted"
        objects: [corresppersons_insert_input!]!
    ): corresppersons_mutation_response
    "insert a single row into the table: \"corresppersons\""
    insert_corresppersons_one(
        "upsert condition"
        if_matched: corresppersons_if_matched,
        "the row to be inserted"
        object: corresppersons_insert_input!
    ): corresppersons
    "insert data into the table: \"crew\""
    insert_crew(
        "the rows to be inserted"
        objects: [crew_insert_input!]!,
        "upsert condition"
        on_conflict: crew_on_conflict
    ): crew_mutation_response
    "insert data into the table: \"crew_breach\""
    insert_crew_breach(
        "the rows to be inserted"
        objects: [crew_breach_insert_input!]!,
        "upsert condition"
        on_conflict: crew_breach_on_conflict
    ): crew_breach_mutation_response
    "insert a single row into the table: \"crew_breach\""
    insert_crew_breach_one(
        "the row to be inserted"
        object: crew_breach_insert_input!,
        "upsert condition"
        on_conflict: crew_breach_on_conflict
    ): crew_breach
    "insert data into the table: \"crew_calendar\""
    insert_crew_calendar(
        "the rows to be inserted"
        objects: [crew_calendar_insert_input!]!,
        "upsert condition"
        on_conflict: crew_calendar_on_conflict
    ): crew_calendar_mutation_response
    "insert a single row into the table: \"crew_calendar\""
    insert_crew_calendar_one(
        "the row to be inserted"
        object: crew_calendar_insert_input!,
        "upsert condition"
        on_conflict: crew_calendar_on_conflict
    ): crew_calendar
    "insert data into the table: \"crew_driver\""
    insert_crew_driver(
        "the rows to be inserted"
        objects: [crew_driver_insert_input!]!,
        "upsert condition"
        on_conflict: crew_driver_on_conflict
    ): crew_driver_mutation_response
    "insert a single row into the table: \"crew_driver\""
    insert_crew_driver_one(
        "the row to be inserted"
        object: crew_driver_insert_input!,
        "upsert condition"
        on_conflict: crew_driver_on_conflict
    ): crew_driver
    "insert a single row into the table: \"crew\""
    insert_crew_one(
        "the row to be inserted"
        object: crew_insert_input!,
        "upsert condition"
        on_conflict: crew_on_conflict
    ): crew
    "insert data into the table: \"crew_permission\""
    insert_crew_permission(
        "the rows to be inserted"
        objects: [crew_permission_insert_input!]!,
        "upsert condition"
        on_conflict: crew_permission_on_conflict
    ): crew_permission_mutation_response
    "insert a single row into the table: \"crew_permission\""
    insert_crew_permission_one(
        "the row to be inserted"
        object: crew_permission_insert_input!,
        "upsert condition"
        on_conflict: crew_permission_on_conflict
    ): crew_permission
    "insert data into the table: \"crew_request\""
    insert_crew_request(
        "the rows to be inserted"
        objects: [crew_request_insert_input!]!,
        "upsert condition"
        on_conflict: crew_request_on_conflict
    ): crew_request_mutation_response
    "insert a single row into the table: \"crew_request\""
    insert_crew_request_one(
        "the row to be inserted"
        object: crew_request_insert_input!,
        "upsert condition"
        on_conflict: crew_request_on_conflict
    ): crew_request
    "insert data into the table: \"crew_request_status\""
    insert_crew_request_status(
        "the rows to be inserted"
        objects: [crew_request_status_insert_input!]!,
        "upsert condition"
        on_conflict: crew_request_status_on_conflict
    ): crew_request_status_mutation_response
    "insert a single row into the table: \"crew_request_status\""
    insert_crew_request_status_one(
        "the row to be inserted"
        object: crew_request_status_insert_input!,
        "upsert condition"
        on_conflict: crew_request_status_on_conflict
    ): crew_request_status
    "insert data into the table: \"crew_status\""
    insert_crew_status(
        "the rows to be inserted"
        objects: [crew_status_insert_input!]!,
        "upsert condition"
        on_conflict: crew_status_on_conflict
    ): crew_status_mutation_response
    "insert a single row into the table: \"crew_status\""
    insert_crew_status_one(
        "the row to be inserted"
        object: crew_status_insert_input!,
        "upsert condition"
        on_conflict: crew_status_on_conflict
    ): crew_status
    "insert data into the table: \"crew_zone\""
    insert_crew_zone(
        "the rows to be inserted"
        objects: [crew_zone_insert_input!]!,
        "upsert condition"
        on_conflict: crew_zone_on_conflict
    ): crew_zone_mutation_response
    "insert a single row into the table: \"crew_zone\""
    insert_crew_zone_one(
        "the row to be inserted"
        object: crew_zone_insert_input!,
        "upsert condition"
        on_conflict: crew_zone_on_conflict
    ): crew_zone
    "insert data into the table: \"event_status\""
    insert_event_status(
        "the rows to be inserted"
        objects: [event_status_insert_input!]!,
        "upsert condition"
        on_conflict: event_status_on_conflict
    ): event_status_mutation_response
    "insert a single row into the table: \"event_status\""
    insert_event_status_one(
        "the row to be inserted"
        object: event_status_insert_input!,
        "upsert condition"
        on_conflict: event_status_on_conflict
    ): event_status
    "insert data into the table: \"events\""
    insert_events(
        "the rows to be inserted"
        objects: [events_insert_input!]!,
        "upsert condition"
        on_conflict: events_on_conflict
    ): events_mutation_response
    "insert a single row into the table: \"events\""
    insert_events_one(
        "the row to be inserted"
        object: events_insert_input!,
        "upsert condition"
        on_conflict: events_on_conflict
    ): events
    "insert data into the table: \"eventsdescription\""
    insert_eventsdescription(
        "upsert condition"
        if_matched: eventsdescription_if_matched,
        "the rows to be inserted"
        objects: [eventsdescription_insert_input!]!
    ): eventsdescription_mutation_response
    "insert a single row into the table: \"eventsdescription\""
    insert_eventsdescription_one(
        "upsert condition"
        if_matched: eventsdescription_if_matched,
        "the row to be inserted"
        object: eventsdescription_insert_input!
    ): eventsdescription
    "insert data into the table: \"filters\""
    insert_filters(
        "the rows to be inserted"
        objects: [filters_insert_input!]!,
        "upsert condition"
        on_conflict: filters_on_conflict
    ): filters_mutation_response
    "insert a single row into the table: \"filters\""
    insert_filters_one(
        "the row to be inserted"
        object: filters_insert_input!,
        "upsert condition"
        on_conflict: filters_on_conflict
    ): filters
    "insert data into the table: \"events\""
    insert_monas_events(
        "upsert condition"
        if_matched: monas_events_if_matched,
        "the rows to be inserted"
        objects: [monas_events_insert_input!]!
    ): monas_events_mutation_response
    "insert a single row into the table: \"events\""
    insert_monas_events_one(
        "upsert condition"
        if_matched: monas_events_if_matched,
        "the row to be inserted"
        object: monas_events_insert_input!
    ): monas_events
    "insert data into the table: \"objects\""
    insert_monas_objects(
        "upsert condition"
        if_matched: monas_objects_if_matched,
        "the rows to be inserted"
        objects: [monas_objects_insert_input!]!
    ): monas_objects_mutation_response
    "insert a single row into the table: \"objects\""
    insert_monas_objects_one(
        "upsert condition"
        if_matched: monas_objects_if_matched,
        "the row to be inserted"
        object: monas_objects_insert_input!
    ): monas_objects
    "insert data into the table: \"monas_related\""
    insert_monas_related(
        "the rows to be inserted"
        objects: [monas_related_insert_input!]!,
        "upsert condition"
        on_conflict: monas_related_on_conflict
    ): monas_related_mutation_response
    "insert a single row into the table: \"monas_related\""
    insert_monas_related_one(
        "the row to be inserted"
        object: monas_related_insert_input!,
        "upsert condition"
        on_conflict: monas_related_on_conflict
    ): monas_related
    "insert data into the table: \"object\""
    insert_object(
        "the rows to be inserted"
        objects: [object_insert_input!]!,
        "upsert condition"
        on_conflict: object_on_conflict
    ): object_mutation_response
    "insert data into the table: \"object_image\""
    insert_object_image(
        "the rows to be inserted"
        objects: [object_image_insert_input!]!,
        "upsert condition"
        on_conflict: object_image_on_conflict
    ): object_image_mutation_response
    "insert a single row into the table: \"object_image\""
    insert_object_image_one(
        "the row to be inserted"
        object: object_image_insert_input!,
        "upsert condition"
        on_conflict: object_image_on_conflict
    ): object_image
    "insert data into the table: \"object_key\""
    insert_object_key(
        "the rows to be inserted"
        objects: [object_key_insert_input!]!,
        "upsert condition"
        on_conflict: object_key_on_conflict
    ): object_key_mutation_response
    "insert data into the table: \"object_key_box\""
    insert_object_key_box(
        "the rows to be inserted"
        objects: [object_key_box_insert_input!]!,
        "upsert condition"
        on_conflict: object_key_box_on_conflict
    ): object_key_box_mutation_response
    "insert a single row into the table: \"object_key_box\""
    insert_object_key_box_one(
        "the row to be inserted"
        object: object_key_box_insert_input!,
        "upsert condition"
        on_conflict: object_key_box_on_conflict
    ): object_key_box
    "insert a single row into the table: \"object_key\""
    insert_object_key_one(
        "the row to be inserted"
        object: object_key_insert_input!,
        "upsert condition"
        on_conflict: object_key_on_conflict
    ): object_key
    "insert data into the table: \"object_key_rels\""
    insert_object_key_rels(
        "the rows to be inserted"
        objects: [object_key_rels_insert_input!]!,
        "upsert condition"
        on_conflict: object_key_rels_on_conflict
    ): object_key_rels_mutation_response
    "insert a single row into the table: \"object_key_rels\""
    insert_object_key_rels_one(
        "the row to be inserted"
        object: object_key_rels_insert_input!,
        "upsert condition"
        on_conflict: object_key_rels_on_conflict
    ): object_key_rels
    "insert data into the table: \"object_modem\""
    insert_object_modem(
        "the rows to be inserted"
        objects: [object_modem_insert_input!]!,
        "upsert condition"
        on_conflict: object_modem_on_conflict
    ): object_modem_mutation_response
    "insert a single row into the table: \"object_modem\""
    insert_object_modem_one(
        "the row to be inserted"
        object: object_modem_insert_input!,
        "upsert condition"
        on_conflict: object_modem_on_conflict
    ): object_modem
    "insert a single row into the table: \"object\""
    insert_object_one(
        "the row to be inserted"
        object: object_insert_input!,
        "upsert condition"
        on_conflict: object_on_conflict
    ): object
    "insert data into the table: \"object_user_rel\""
    insert_object_user_rel(
        "the rows to be inserted"
        objects: [object_user_rel_insert_input!]!,
        "upsert condition"
        on_conflict: object_user_rel_on_conflict
    ): object_user_rel_mutation_response
    "insert a single row into the table: \"object_user_rel\""
    insert_object_user_rel_one(
        "the row to be inserted"
        object: object_user_rel_insert_input!,
        "upsert condition"
        on_conflict: object_user_rel_on_conflict
    ): object_user_rel
    "insert data into the table: \"objectimages\""
    insert_objectimages(
        "upsert condition"
        if_matched: objectimages_if_matched,
        "the rows to be inserted"
        objects: [objectimages_insert_input!]!
    ): objectimages_mutation_response
    "insert a single row into the table: \"objectimages\""
    insert_objectimages_one(
        "upsert condition"
        if_matched: objectimages_if_matched,
        "the row to be inserted"
        object: objectimages_insert_input!
    ): objectimages
    "insert data into the table: \"provider\""
    insert_provider(
        "the rows to be inserted"
        objects: [provider_insert_input!]!,
        "upsert condition"
        on_conflict: provider_on_conflict
    ): provider_mutation_response
    "insert a single row into the table: \"provider\""
    insert_provider_one(
        "the row to be inserted"
        object: provider_insert_input!,
        "upsert condition"
        on_conflict: provider_on_conflict
    ): provider
    "insert data into the table: \"reason_for_cancellation\""
    insert_reason_for_cancellation(
        "the rows to be inserted"
        objects: [reason_for_cancellation_insert_input!]!,
        "upsert condition"
        on_conflict: reason_for_cancellation_on_conflict
    ): reason_for_cancellation_mutation_response
    "insert a single row into the table: \"reason_for_cancellation\""
    insert_reason_for_cancellation_one(
        "the row to be inserted"
        object: reason_for_cancellation_insert_input!,
        "upsert condition"
        on_conflict: reason_for_cancellation_on_conflict
    ): reason_for_cancellation
    "insert data into the table: \"task_type\""
    insert_task_type(
        "the rows to be inserted"
        objects: [task_type_insert_input!]!,
        "upsert condition"
        on_conflict: task_type_on_conflict
    ): task_type_mutation_response
    "insert a single row into the table: \"task_type\""
    insert_task_type_one(
        "the row to be inserted"
        object: task_type_insert_input!,
        "upsert condition"
        on_conflict: task_type_on_conflict
    ): task_type
    "insert data into the table: \"user_settings\""
    insert_user_settings(
        "the rows to be inserted"
        objects: [user_settings_insert_input!]!,
        "upsert condition"
        on_conflict: user_settings_on_conflict
    ): user_settings_mutation_response
    "insert a single row into the table: \"user_settings\""
    insert_user_settings_one(
        "the row to be inserted"
        object: user_settings_insert_input!,
        "upsert condition"
        on_conflict: user_settings_on_conflict
    ): user_settings
    "insert data into the table: \"user_type\""
    insert_user_type(
        "the rows to be inserted"
        objects: [user_type_insert_input!]!,
        "upsert condition"
        on_conflict: user_type_on_conflict
    ): user_type_mutation_response
    "insert a single row into the table: \"user_type\""
    insert_user_type_one(
        "the row to be inserted"
        object: user_type_insert_input!,
        "upsert condition"
        on_conflict: user_type_on_conflict
    ): user_type
    storeFile(base64: String!, namespace: String, path: String!): FilestoreSave
    "update data of the table: \"central\""
    update_central(
        "sets the columns of the filtered rows to the given values"
        _set: central_set_input,
        "filter the rows which have to be updated"
        where: central_bool_exp!
    ): central_mutation_response
    "update single row of the table: \"central\""
    update_central_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: central_set_input,
        pk_columns: central_pk_columns_input!
    ): central
    "update data of the table: \"city\""
    update_city(
        "sets the columns of the filtered rows to the given values"
        _set: city_set_input,
        "filter the rows which have to be updated"
        where: city_bool_exp!
    ): city_mutation_response
    "update single row of the table: \"city\""
    update_city_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: city_set_input,
        pk_columns: city_pk_columns_input!
    ): city
    "update data of the table: \"coresppersons\""
    update_coresppersons(
        "increments the numeric columns with given value of the filtered values"
        _inc: coresppersons_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: coresppersons_set_input,
        "filter the rows which have to be updated"
        where: coresppersons_bool_exp!
    ): coresppersons_mutation_response
    "update single row of the table: \"coresppersons\""
    update_coresppersons_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: coresppersons_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: coresppersons_set_input,
        pk_columns: coresppersons_pk_columns_input!
    ): coresppersons
    "update data of the table: \"corresppersons\""
    update_corresppersons(
        "increments the numeric columns with given value of the filtered values"
        _inc: corresppersons_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: corresppersons_set_input,
        "filter the rows which have to be updated"
        where: corresppersons_bool_exp!
    ): corresppersons_mutation_response
    "update single row of the table: \"corresppersons\""
    update_corresppersons_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: corresppersons_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: corresppersons_set_input,
        pk_columns: corresppersons_pk_columns_input!
    ): corresppersons
    "update data of the table: \"crew\""
    update_crew(
        "sets the columns of the filtered rows to the given values"
        _set: crew_set_input,
        "filter the rows which have to be updated"
        where: crew_bool_exp!
    ): crew_mutation_response
    "update data of the table: \"crew_breach\""
    update_crew_breach(
        "sets the columns of the filtered rows to the given values"
        _set: crew_breach_set_input,
        "filter the rows which have to be updated"
        where: crew_breach_bool_exp!
    ): crew_breach_mutation_response
    "update single row of the table: \"crew_breach\""
    update_crew_breach_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: crew_breach_set_input,
        pk_columns: crew_breach_pk_columns_input!
    ): crew_breach
    "update single row of the table: \"crew\""
    update_crew_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: crew_set_input,
        pk_columns: crew_pk_columns_input!
    ): crew
    "update data of the table: \"crew_calendar\""
    update_crew_calendar(
        "increments the numeric columns with given value of the filtered values"
        _inc: crew_calendar_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: crew_calendar_set_input,
        "filter the rows which have to be updated"
        where: crew_calendar_bool_exp!
    ): crew_calendar_mutation_response
    "update single row of the table: \"crew_calendar\""
    update_crew_calendar_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: crew_calendar_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: crew_calendar_set_input,
        pk_columns: crew_calendar_pk_columns_input!
    ): crew_calendar
    "update data of the table: \"crew_driver\""
    update_crew_driver(
        "sets the columns of the filtered rows to the given values"
        _set: crew_driver_set_input,
        "filter the rows which have to be updated"
        where: crew_driver_bool_exp!
    ): crew_driver_mutation_response
    "update single row of the table: \"crew_driver\""
    update_crew_driver_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: crew_driver_set_input,
        pk_columns: crew_driver_pk_columns_input!
    ): crew_driver
    "update data of the table: \"crew_permission\""
    update_crew_permission(
        "sets the columns of the filtered rows to the given values"
        _set: crew_permission_set_input,
        "filter the rows which have to be updated"
        where: crew_permission_bool_exp!
    ): crew_permission_mutation_response
    "update single row of the table: \"crew_permission\""
    update_crew_permission_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: crew_permission_set_input,
        pk_columns: crew_permission_pk_columns_input!
    ): crew_permission
    "update data of the table: \"crew_request\""
    update_crew_request(
        "sets the columns of the filtered rows to the given values"
        _set: crew_request_set_input,
        "filter the rows which have to be updated"
        where: crew_request_bool_exp!
    ): crew_request_mutation_response
    "update single row of the table: \"crew_request\""
    update_crew_request_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: crew_request_set_input,
        pk_columns: crew_request_pk_columns_input!
    ): crew_request
    "update data of the table: \"crew_request_status\""
    update_crew_request_status(
        "sets the columns of the filtered rows to the given values"
        _set: crew_request_status_set_input,
        "filter the rows which have to be updated"
        where: crew_request_status_bool_exp!
    ): crew_request_status_mutation_response
    "update single row of the table: \"crew_request_status\""
    update_crew_request_status_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: crew_request_status_set_input,
        pk_columns: crew_request_status_pk_columns_input!
    ): crew_request_status
    "update data of the table: \"crew_status\""
    update_crew_status(
        "sets the columns of the filtered rows to the given values"
        _set: crew_status_set_input,
        "filter the rows which have to be updated"
        where: crew_status_bool_exp!
    ): crew_status_mutation_response
    "update single row of the table: \"crew_status\""
    update_crew_status_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: crew_status_set_input,
        pk_columns: crew_status_pk_columns_input!
    ): crew_status
    "update data of the table: \"crew_zone\""
    update_crew_zone(
        "sets the columns of the filtered rows to the given values"
        _set: crew_zone_set_input,
        "filter the rows which have to be updated"
        where: crew_zone_bool_exp!
    ): crew_zone_mutation_response
    "update single row of the table: \"crew_zone\""
    update_crew_zone_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: crew_zone_set_input,
        pk_columns: crew_zone_pk_columns_input!
    ): crew_zone
    "update data of the table: \"event_status\""
    update_event_status(
        "sets the columns of the filtered rows to the given values"
        _set: event_status_set_input,
        "filter the rows which have to be updated"
        where: event_status_bool_exp!
    ): event_status_mutation_response
    "update single row of the table: \"event_status\""
    update_event_status_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: event_status_set_input,
        pk_columns: event_status_pk_columns_input!
    ): event_status
    "update data of the table: \"events\""
    update_events(
        "increments the numeric columns with given value of the filtered values"
        _inc: events_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: events_set_input,
        "filter the rows which have to be updated"
        where: events_bool_exp!
    ): events_mutation_response
    "update single row of the table: \"events\""
    update_events_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: events_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: events_set_input,
        pk_columns: events_pk_columns_input!
    ): events
    "update data of the table: \"eventsdescription\""
    update_eventsdescription(
        "increments the numeric columns with given value of the filtered values"
        _inc: eventsdescription_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: eventsdescription_set_input,
        "filter the rows which have to be updated"
        where: eventsdescription_bool_exp!
    ): eventsdescription_mutation_response
    "update single row of the table: \"eventsdescription\""
    update_eventsdescription_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: eventsdescription_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: eventsdescription_set_input,
        pk_columns: eventsdescription_pk_columns_input!
    ): eventsdescription
    "update data of the table: \"filters\""
    update_filters(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: filters_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: filters_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: filters_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: filters_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: filters_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: filters_set_input,
        "filter the rows which have to be updated"
        where: filters_bool_exp!
    ): filters_mutation_response
    "update single row of the table: \"filters\""
    update_filters_by_pk(
        "append existing jsonb value of filtered columns with new jsonb value"
        _append: filters_append_input,
        "delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
        _delete_at_path: filters_delete_at_path_input,
        "delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
        _delete_elem: filters_delete_elem_input,
        "delete key/value pair or string element. key/value pairs are matched based on their key value"
        _delete_key: filters_delete_key_input,
        "prepend existing jsonb value of filtered columns with new jsonb value"
        _prepend: filters_prepend_input,
        "sets the columns of the filtered rows to the given values"
        _set: filters_set_input,
        pk_columns: filters_pk_columns_input!
    ): filters
    "update data of the table: \"events\""
    update_monas_events(
        "increments the numeric columns with given value of the filtered values"
        _inc: monas_events_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: monas_events_set_input,
        "filter the rows which have to be updated"
        where: monas_events_bool_exp!
    ): monas_events_mutation_response
    "update single row of the table: \"events\""
    update_monas_events_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: monas_events_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: monas_events_set_input,
        pk_columns: monas_events_pk_columns_input!
    ): monas_events
    "update data of the table: \"objects\""
    update_monas_objects(
        "increments the numeric columns with given value of the filtered values"
        _inc: monas_objects_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: monas_objects_set_input,
        "filter the rows which have to be updated"
        where: monas_objects_bool_exp!
    ): monas_objects_mutation_response
    "update single row of the table: \"objects\""
    update_monas_objects_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: monas_objects_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: monas_objects_set_input,
        pk_columns: monas_objects_pk_columns_input!
    ): monas_objects
    "update data of the table: \"monas_related\""
    update_monas_related(
        "increments the numeric columns with given value of the filtered values"
        _inc: monas_related_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: monas_related_set_input,
        "filter the rows which have to be updated"
        where: monas_related_bool_exp!
    ): monas_related_mutation_response
    "update single row of the table: \"monas_related\""
    update_monas_related_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: monas_related_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: monas_related_set_input,
        pk_columns: monas_related_pk_columns_input!
    ): monas_related
    "update data of the table: \"object\""
    update_object(
        "increments the numeric columns with given value of the filtered values"
        _inc: object_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: object_set_input,
        "filter the rows which have to be updated"
        where: object_bool_exp!
    ): object_mutation_response
    "update single row of the table: \"object\""
    update_object_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: object_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: object_set_input,
        pk_columns: object_pk_columns_input!
    ): object
    "update data of the table: \"object_image\""
    update_object_image(
        "sets the columns of the filtered rows to the given values"
        _set: object_image_set_input,
        "filter the rows which have to be updated"
        where: object_image_bool_exp!
    ): object_image_mutation_response
    "update single row of the table: \"object_image\""
    update_object_image_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: object_image_set_input,
        pk_columns: object_image_pk_columns_input!
    ): object_image
    "update data of the table: \"object_key\""
    update_object_key(
        "sets the columns of the filtered rows to the given values"
        _set: object_key_set_input,
        "filter the rows which have to be updated"
        where: object_key_bool_exp!
    ): object_key_mutation_response
    "update data of the table: \"object_key_box\""
    update_object_key_box(
        "sets the columns of the filtered rows to the given values"
        _set: object_key_box_set_input,
        "filter the rows which have to be updated"
        where: object_key_box_bool_exp!
    ): object_key_box_mutation_response
    "update single row of the table: \"object_key_box\""
    update_object_key_box_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: object_key_box_set_input,
        pk_columns: object_key_box_pk_columns_input!
    ): object_key_box
    "update single row of the table: \"object_key\""
    update_object_key_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: object_key_set_input,
        pk_columns: object_key_pk_columns_input!
    ): object_key
    "update data of the table: \"object_key_rels\""
    update_object_key_rels(
        "sets the columns of the filtered rows to the given values"
        _set: object_key_rels_set_input,
        "filter the rows which have to be updated"
        where: object_key_rels_bool_exp!
    ): object_key_rels_mutation_response
    "update single row of the table: \"object_key_rels\""
    update_object_key_rels_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: object_key_rels_set_input,
        pk_columns: object_key_rels_pk_columns_input!
    ): object_key_rels
    "update data of the table: \"object_modem\""
    update_object_modem(
        "sets the columns of the filtered rows to the given values"
        _set: object_modem_set_input,
        "filter the rows which have to be updated"
        where: object_modem_bool_exp!
    ): object_modem_mutation_response
    "update single row of the table: \"object_modem\""
    update_object_modem_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: object_modem_set_input,
        pk_columns: object_modem_pk_columns_input!
    ): object_modem
    "update data of the table: \"object_user_rel\""
    update_object_user_rel(
        "sets the columns of the filtered rows to the given values"
        _set: object_user_rel_set_input,
        "filter the rows which have to be updated"
        where: object_user_rel_bool_exp!
    ): object_user_rel_mutation_response
    "update single row of the table: \"object_user_rel\""
    update_object_user_rel_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: object_user_rel_set_input,
        pk_columns: object_user_rel_pk_columns_input!
    ): object_user_rel
    "update data of the table: \"objectimages\""
    update_objectimages(
        "increments the numeric columns with given value of the filtered values"
        _inc: objectimages_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: objectimages_set_input,
        "filter the rows which have to be updated"
        where: objectimages_bool_exp!
    ): objectimages_mutation_response
    "update single row of the table: \"objectimages\""
    update_objectimages_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: objectimages_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: objectimages_set_input,
        pk_columns: objectimages_pk_columns_input!
    ): objectimages
    "update data of the table: \"provider\""
    update_provider(
        "sets the columns of the filtered rows to the given values"
        _set: provider_set_input,
        "filter the rows which have to be updated"
        where: provider_bool_exp!
    ): provider_mutation_response
    "update single row of the table: \"provider\""
    update_provider_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: provider_set_input,
        pk_columns: provider_pk_columns_input!
    ): provider
    "update data of the table: \"reason_for_cancellation\""
    update_reason_for_cancellation(
        "sets the columns of the filtered rows to the given values"
        _set: reason_for_cancellation_set_input,
        "filter the rows which have to be updated"
        where: reason_for_cancellation_bool_exp!
    ): reason_for_cancellation_mutation_response
    "update single row of the table: \"reason_for_cancellation\""
    update_reason_for_cancellation_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: reason_for_cancellation_set_input,
        pk_columns: reason_for_cancellation_pk_columns_input!
    ): reason_for_cancellation
    "update data of the table: \"task_type\""
    update_task_type(
        "sets the columns of the filtered rows to the given values"
        _set: task_type_set_input,
        "filter the rows which have to be updated"
        where: task_type_bool_exp!
    ): task_type_mutation_response
    "update single row of the table: \"task_type\""
    update_task_type_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: task_type_set_input,
        pk_columns: task_type_pk_columns_input!
    ): task_type
    "update data of the table: \"user_settings\""
    update_user_settings(
        "increments the numeric columns with given value of the filtered values"
        _inc: user_settings_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: user_settings_set_input,
        "filter the rows which have to be updated"
        where: user_settings_bool_exp!
    ): user_settings_mutation_response
    "update single row of the table: \"user_settings\""
    update_user_settings_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: user_settings_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: user_settings_set_input,
        pk_columns: user_settings_pk_columns_input!
    ): user_settings
    "update data of the table: \"user_type\""
    update_user_type(
        "sets the columns of the filtered rows to the given values"
        _set: user_type_set_input,
        "filter the rows which have to be updated"
        where: user_type_bool_exp!
    ): user_type_mutation_response
    "update single row of the table: \"user_type\""
    update_user_type_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: user_type_set_input,
        pk_columns: user_type_pk_columns_input!
    ): user_type
}

"columns and relationships of \"object\""
type object {
    address: String
    city: city_enum
    contract_no: String
    contract_object_no: String
    description: String
    id: uuid!
    "An array relationship"
    images(
        "distinct select on columns"
        distinct_on: [object_image_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_image_order_by!],
        "filter the rows returned"
        where: object_image_bool_exp
    ): [object_image!]!
    "An aggregate relationship"
    images_aggregate(
        "distinct select on columns"
        distinct_on: [object_image_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_image_order_by!],
        "filter the rows returned"
        where: object_image_bool_exp
    ): object_image_aggregate!
    is_atm: Boolean
    is_crew_autoasigned: Boolean!
    "An array relationship"
    keys(
        "distinct select on columns"
        distinct_on: [object_key_rels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_rels_order_by!],
        "filter the rows returned"
        where: object_key_rels_bool_exp
    ): [object_key_rels!]!
    "An aggregate relationship"
    keys_aggregate(
        "distinct select on columns"
        distinct_on: [object_key_rels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_rels_order_by!],
        "filter the rows returned"
        where: object_key_rels_bool_exp
    ): object_key_rels_aggregate!
    latitude: numeric
    longitude: numeric
    "An array relationship"
    modems(
        "distinct select on columns"
        distinct_on: [object_modem_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_modem_order_by!],
        "filter the rows returned"
        where: object_modem_bool_exp
    ): [object_modem!]!
    "An aggregate relationship"
    modems_aggregate(
        "distinct select on columns"
        distinct_on: [object_modem_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_modem_order_by!],
        "filter the rows returned"
        where: object_modem_bool_exp
    ): object_modem_aggregate!
    name: String
    navision_id: Int
    phone: String
    provider_id: Int
    provider_name: provider_enum
    provider_object: monas_objects
    "An array relationship"
    users(
        "distinct select on columns"
        distinct_on: [object_user_rel_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_user_rel_order_by!],
        "filter the rows returned"
        where: object_user_rel_bool_exp
    ): [object_user_rel!]!
    "An aggregate relationship"
    users_aggregate(
        "distinct select on columns"
        distinct_on: [object_user_rel_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_user_rel_order_by!],
        "filter the rows returned"
        where: object_user_rel_bool_exp
    ): object_user_rel_aggregate!
}

"aggregated selection of \"object\""
type object_aggregate {
    aggregate: object_aggregate_fields
    nodes: [object!]!
}

"aggregate fields of \"object\""
type object_aggregate_fields {
    avg: object_avg_fields
    count(columns: [object_select_column!], distinct: Boolean): Int!
    max: object_max_fields
    min: object_min_fields
    stddev: object_stddev_fields
    stddev_pop: object_stddev_pop_fields
    stddev_samp: object_stddev_samp_fields
    sum: object_sum_fields
    var_pop: object_var_pop_fields
    var_samp: object_var_samp_fields
    variance: object_variance_fields
}

"aggregate avg on columns"
type object_avg_fields {
    latitude: Float
    longitude: Float
    navision_id: Float
    provider_id: Float
}

"src is either url to image, or base64 content"
type object_image {
    id: uuid!
    "An object relationship"
    object: object!
    object_id: uuid!
    src: String!
}

"aggregated selection of \"object_image\""
type object_image_aggregate {
    aggregate: object_image_aggregate_fields
    nodes: [object_image!]!
}

"aggregate fields of \"object_image\""
type object_image_aggregate_fields {
    count(columns: [object_image_select_column!], distinct: Boolean): Int!
    max: object_image_max_fields
    min: object_image_min_fields
}

"aggregate max on columns"
type object_image_max_fields {
    id: uuid
    object_id: uuid
    src: String
}

"aggregate min on columns"
type object_image_min_fields {
    id: uuid
    object_id: uuid
    src: String
}

"response of any mutation on the table \"object_image\""
type object_image_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object_image!]!
}

"columns and relationships of \"object_key\""
type object_key {
    crew_id: uuid
    id: uuid!
    "An object relationship"
    object: object_key_rels
    set_name: String!
}

"aggregated selection of \"object_key\""
type object_key_aggregate {
    aggregate: object_key_aggregate_fields
    nodes: [object_key!]!
}

"aggregate fields of \"object_key\""
type object_key_aggregate_fields {
    count(columns: [object_key_select_column!], distinct: Boolean): Int!
    max: object_key_max_fields
    min: object_key_min_fields
}

"columns and relationships of \"object_key_box\""
type object_key_box {
    crew_id: uuid
    id: uuid!
    set_name: String!
}

"aggregated selection of \"object_key_box\""
type object_key_box_aggregate {
    aggregate: object_key_box_aggregate_fields
    nodes: [object_key_box!]!
}

"aggregate fields of \"object_key_box\""
type object_key_box_aggregate_fields {
    count(columns: [object_key_box_select_column!], distinct: Boolean): Int!
    max: object_key_box_max_fields
    min: object_key_box_min_fields
}

"aggregate max on columns"
type object_key_box_max_fields {
    crew_id: uuid
    id: uuid
    set_name: String
}

"aggregate min on columns"
type object_key_box_min_fields {
    crew_id: uuid
    id: uuid
    set_name: String
}

"response of any mutation on the table \"object_key_box\""
type object_key_box_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object_key_box!]!
}

"aggregate max on columns"
type object_key_max_fields {
    crew_id: uuid
    id: uuid
    set_name: String
}

"aggregate min on columns"
type object_key_min_fields {
    crew_id: uuid
    id: uuid
    set_name: String
}

"response of any mutation on the table \"object_key\""
type object_key_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object_key!]!
}

"many to many"
type object_key_rels {
    box_id: uuid!
    id: uuid!
    "An object relationship"
    key: object_key!
    key_id: uuid!
    "An object relationship"
    object: object!
    object_id: uuid!
}

"aggregated selection of \"object_key_rels\""
type object_key_rels_aggregate {
    aggregate: object_key_rels_aggregate_fields
    nodes: [object_key_rels!]!
}

"aggregate fields of \"object_key_rels\""
type object_key_rels_aggregate_fields {
    count(columns: [object_key_rels_select_column!], distinct: Boolean): Int!
    max: object_key_rels_max_fields
    min: object_key_rels_min_fields
}

"aggregate max on columns"
type object_key_rels_max_fields {
    box_id: uuid
    id: uuid
    key_id: uuid
    object_id: uuid
}

"aggregate min on columns"
type object_key_rels_min_fields {
    box_id: uuid
    id: uuid
    key_id: uuid
    object_id: uuid
}

"response of any mutation on the table \"object_key_rels\""
type object_key_rels_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object_key_rels!]!
}

"aggregate max on columns"
type object_max_fields {
    address: String
    contract_no: String
    contract_object_no: String
    description: String
    id: uuid
    latitude: numeric
    longitude: numeric
    name: String
    navision_id: Int
    phone: String
    provider_id: Int
}

"aggregate min on columns"
type object_min_fields {
    address: String
    contract_no: String
    contract_object_no: String
    description: String
    id: uuid
    latitude: numeric
    longitude: numeric
    name: String
    navision_id: Int
    phone: String
    provider_id: Int
}

"columns and relationships of \"object_modem\""
type object_modem {
    area_no: String!
    central: central_enum
    id: uuid!
    "An object relationship"
    object: object!
    object_id: uuid!
}

"aggregated selection of \"object_modem\""
type object_modem_aggregate {
    aggregate: object_modem_aggregate_fields
    nodes: [object_modem!]!
}

"aggregate fields of \"object_modem\""
type object_modem_aggregate_fields {
    count(columns: [object_modem_select_column!], distinct: Boolean): Int!
    max: object_modem_max_fields
    min: object_modem_min_fields
}

"aggregate max on columns"
type object_modem_max_fields {
    area_no: String
    id: uuid
    object_id: uuid
}

"aggregate min on columns"
type object_modem_min_fields {
    area_no: String
    id: uuid
    object_id: uuid
}

"response of any mutation on the table \"object_modem\""
type object_modem_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object_modem!]!
}

"response of any mutation on the table \"object\""
type object_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object!]!
}

"aggregate stddev on columns"
type object_stddev_fields {
    latitude: Float
    longitude: Float
    navision_id: Float
    provider_id: Float
}

"aggregate stddev_pop on columns"
type object_stddev_pop_fields {
    latitude: Float
    longitude: Float
    navision_id: Float
    provider_id: Float
}

"aggregate stddev_samp on columns"
type object_stddev_samp_fields {
    latitude: Float
    longitude: Float
    navision_id: Float
    provider_id: Float
}

"aggregate sum on columns"
type object_sum_fields {
    latitude: numeric
    longitude: numeric
    navision_id: Int
    provider_id: Int
}

"User <-> Object relation with additional business columns"
type object_user_rel {
    is_subscribed_yesterdays_report: Boolean!
    "An object relationship"
    object: object!
    object_id: uuid!
    user_id: uuid!
    user_type: user_type_enum
}

"aggregated selection of \"object_user_rel\""
type object_user_rel_aggregate {
    aggregate: object_user_rel_aggregate_fields
    nodes: [object_user_rel!]!
}

"aggregate fields of \"object_user_rel\""
type object_user_rel_aggregate_fields {
    count(columns: [object_user_rel_select_column!], distinct: Boolean): Int!
    max: object_user_rel_max_fields
    min: object_user_rel_min_fields
}

"aggregate max on columns"
type object_user_rel_max_fields {
    object_id: uuid
    user_id: uuid
}

"aggregate min on columns"
type object_user_rel_min_fields {
    object_id: uuid
    user_id: uuid
}

"response of any mutation on the table \"object_user_rel\""
type object_user_rel_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [object_user_rel!]!
}

"aggregate var_pop on columns"
type object_var_pop_fields {
    latitude: Float
    longitude: Float
    navision_id: Float
    provider_id: Float
}

"aggregate var_samp on columns"
type object_var_samp_fields {
    latitude: Float
    longitude: Float
    navision_id: Float
    provider_id: Float
}

"aggregate variance on columns"
type object_variance_fields {
    latitude: Float
    longitude: Float
    navision_id: Float
    provider_id: Float
}

"columns and relationships of \"objectimages\""
type objectimages {
    Id: Int!
    defaultimage: String!
    image: binary
    imagename: String
    objectid: Int!
}

"aggregated selection of \"objectimages\""
type objectimages_aggregate {
    aggregate: objectimages_aggregate_fields
    nodes: [objectimages!]!
}

"aggregate fields of \"objectimages\""
type objectimages_aggregate_fields {
    avg: objectimages_avg_fields
    count(column: objectimages_select_column, distinct: Boolean): Int!
    max: objectimages_max_fields
    min: objectimages_min_fields
    stddev: objectimages_stddev_fields
    stddev_pop: objectimages_stddev_pop_fields
    stddev_samp: objectimages_stddev_samp_fields
    sum: objectimages_sum_fields
    var_pop: objectimages_var_pop_fields
    var_samp: objectimages_var_samp_fields
    variance: objectimages_variance_fields
}

"aggregate avg on columns"
type objectimages_avg_fields {
    Id: Float
    objectid: Float
}

"aggregate max on columns"
type objectimages_max_fields {
    Id: Int
    defaultimage: String
    imagename: String
    objectid: Int
}

"aggregate min on columns"
type objectimages_min_fields {
    Id: Int
    defaultimage: String
    imagename: String
    objectid: Int
}

"response of any mutation on the table \"objectimages\""
type objectimages_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [objectimages!]!
}

"aggregate stddev on columns"
type objectimages_stddev_fields {
    Id: Float
    objectid: Float
}

"aggregate stddev_pop on columns"
type objectimages_stddev_pop_fields {
    Id: Float
    objectid: Float
}

"aggregate stddev_samp on columns"
type objectimages_stddev_samp_fields {
    Id: Float
    objectid: Float
}

"aggregate sum on columns"
type objectimages_sum_fields {
    Id: Int
    objectid: Int
}

"aggregate var_pop on columns"
type objectimages_var_pop_fields {
    Id: Float
    objectid: Float
}

"aggregate var_samp on columns"
type objectimages_var_samp_fields {
    Id: Float
    objectid: Float
}

"aggregate variance on columns"
type objectimages_variance_fields {
    Id: Float
    objectid: Float
}

"columns and relationships of \"provider\""
type provider {
    comment: String!
    value: String!
}

"aggregated selection of \"provider\""
type provider_aggregate {
    aggregate: provider_aggregate_fields
    nodes: [provider!]!
}

"aggregate fields of \"provider\""
type provider_aggregate_fields {
    count(columns: [provider_select_column!], distinct: Boolean): Int!
    max: provider_max_fields
    min: provider_min_fields
}

"aggregate max on columns"
type provider_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type provider_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"provider\""
type provider_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [provider!]!
}

type query_root {
    "fetch data from the table: \"central\""
    central(
        "distinct select on columns"
        distinct_on: [central_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [central_order_by!],
        "filter the rows returned"
        where: central_bool_exp
    ): [central!]!
    "fetch aggregated fields from the table: \"central\""
    central_aggregate(
        "distinct select on columns"
        distinct_on: [central_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [central_order_by!],
        "filter the rows returned"
        where: central_bool_exp
    ): central_aggregate!
    "fetch data from the table: \"central\" using primary key columns"
    central_by_pk(value: String!): central
    "fetch data from the table: \"city\""
    city(
        "distinct select on columns"
        distinct_on: [city_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [city_order_by!],
        "filter the rows returned"
        where: city_bool_exp
    ): [city!]!
    "fetch aggregated fields from the table: \"city\""
    city_aggregate(
        "distinct select on columns"
        distinct_on: [city_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [city_order_by!],
        "filter the rows returned"
        where: city_bool_exp
    ): city_aggregate!
    "fetch data from the table: \"city\" using primary key columns"
    city_by_pk(value: String!): city
    "fetch data from the table: \"coresppersons\""
    coresppersons(
        "distinct select on columns"
        distinct_on: [coresppersons_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [coresppersons_order_by!],
        "filter the rows returned"
        where: coresppersons_bool_exp
    ): [coresppersons!]!
    "fetch aggregated fields from the table: \"coresppersons\""
    coresppersons_aggregate(
        "distinct select on columns"
        distinct_on: [coresppersons_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [coresppersons_order_by!],
        "filter the rows returned"
        where: coresppersons_bool_exp
    ): coresppersons_aggregate!
    "fetch data from the table: \"coresppersons\" using primary key columns"
    coresppersons_by_pk(id: String!): coresppersons
    "fetch data from the table: \"corresppersons\""
    corresppersons(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [corresppersons_order_by!],
        "filter the rows returned"
        where: corresppersons_bool_exp
    ): [corresppersons!]!
    "fetch aggregated fields from the table: \"corresppersons\""
    corresppersons_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [corresppersons_order_by!],
        "filter the rows returned"
        where: corresppersons_bool_exp
    ): corresppersons_aggregate!
    "fetch data from the table: \"corresppersons\" using primary key columns"
    corresppersons_by_pk(id: Int!): corresppersons
    "fetch data from the table: \"crew\""
    crew(
        "distinct select on columns"
        distinct_on: [crew_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_order_by!],
        "filter the rows returned"
        where: crew_bool_exp
    ): [crew!]!
    "fetch aggregated fields from the table: \"crew\""
    crew_aggregate(
        "distinct select on columns"
        distinct_on: [crew_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_order_by!],
        "filter the rows returned"
        where: crew_bool_exp
    ): crew_aggregate!
    "fetch data from the table: \"crew_breach\""
    crew_breach(
        "distinct select on columns"
        distinct_on: [crew_breach_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_breach_order_by!],
        "filter the rows returned"
        where: crew_breach_bool_exp
    ): [crew_breach!]!
    "fetch aggregated fields from the table: \"crew_breach\""
    crew_breach_aggregate(
        "distinct select on columns"
        distinct_on: [crew_breach_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_breach_order_by!],
        "filter the rows returned"
        where: crew_breach_bool_exp
    ): crew_breach_aggregate!
    "fetch data from the table: \"crew_breach\" using primary key columns"
    crew_breach_by_pk(id: uuid!): crew_breach
    "fetch data from the table: \"crew\" using primary key columns"
    crew_by_pk(id: uuid!): crew
    "fetch data from the table: \"crew_calendar\""
    crew_calendar(
        "distinct select on columns"
        distinct_on: [crew_calendar_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_calendar_order_by!],
        "filter the rows returned"
        where: crew_calendar_bool_exp
    ): [crew_calendar!]!
    "fetch aggregated fields from the table: \"crew_calendar\""
    crew_calendar_aggregate(
        "distinct select on columns"
        distinct_on: [crew_calendar_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_calendar_order_by!],
        "filter the rows returned"
        where: crew_calendar_bool_exp
    ): crew_calendar_aggregate!
    "fetch data from the table: \"crew_calendar\" using primary key columns"
    crew_calendar_by_pk(id: uuid!): crew_calendar
    "fetch data from the table: \"crew_driver\""
    crew_driver(
        "distinct select on columns"
        distinct_on: [crew_driver_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_driver_order_by!],
        "filter the rows returned"
        where: crew_driver_bool_exp
    ): [crew_driver!]!
    "fetch aggregated fields from the table: \"crew_driver\""
    crew_driver_aggregate(
        "distinct select on columns"
        distinct_on: [crew_driver_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_driver_order_by!],
        "filter the rows returned"
        where: crew_driver_bool_exp
    ): crew_driver_aggregate!
    "fetch data from the table: \"crew_driver\" using primary key columns"
    crew_driver_by_pk(id: uuid!): crew_driver
    "fetch data from the table: \"crew_permission\""
    crew_permission(
        "distinct select on columns"
        distinct_on: [crew_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_permission_order_by!],
        "filter the rows returned"
        where: crew_permission_bool_exp
    ): [crew_permission!]!
    "fetch aggregated fields from the table: \"crew_permission\""
    crew_permission_aggregate(
        "distinct select on columns"
        distinct_on: [crew_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_permission_order_by!],
        "filter the rows returned"
        where: crew_permission_bool_exp
    ): crew_permission_aggregate!
    "fetch data from the table: \"crew_permission\" using primary key columns"
    crew_permission_by_pk(id: uuid!): crew_permission
    "fetch data from the table: \"crew_request\""
    crew_request(
        "distinct select on columns"
        distinct_on: [crew_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_request_order_by!],
        "filter the rows returned"
        where: crew_request_bool_exp
    ): [crew_request!]!
    "fetch aggregated fields from the table: \"crew_request\""
    crew_request_aggregate(
        "distinct select on columns"
        distinct_on: [crew_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_request_order_by!],
        "filter the rows returned"
        where: crew_request_bool_exp
    ): crew_request_aggregate!
    "fetch data from the table: \"crew_request\" using primary key columns"
    crew_request_by_pk(value: String!): crew_request
    "fetch data from the table: \"crew_request_status\""
    crew_request_status(
        "distinct select on columns"
        distinct_on: [crew_request_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_request_status_order_by!],
        "filter the rows returned"
        where: crew_request_status_bool_exp
    ): [crew_request_status!]!
    "fetch aggregated fields from the table: \"crew_request_status\""
    crew_request_status_aggregate(
        "distinct select on columns"
        distinct_on: [crew_request_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_request_status_order_by!],
        "filter the rows returned"
        where: crew_request_status_bool_exp
    ): crew_request_status_aggregate!
    "fetch data from the table: \"crew_request_status\" using primary key columns"
    crew_request_status_by_pk(value: String!): crew_request_status
    "fetch data from the table: \"crew_status\""
    crew_status(
        "distinct select on columns"
        distinct_on: [crew_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_status_order_by!],
        "filter the rows returned"
        where: crew_status_bool_exp
    ): [crew_status!]!
    "fetch aggregated fields from the table: \"crew_status\""
    crew_status_aggregate(
        "distinct select on columns"
        distinct_on: [crew_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_status_order_by!],
        "filter the rows returned"
        where: crew_status_bool_exp
    ): crew_status_aggregate!
    "fetch data from the table: \"crew_status\" using primary key columns"
    crew_status_by_pk(value: String!): crew_status
    "fetch data from the table: \"crew_zone\""
    crew_zone(
        "distinct select on columns"
        distinct_on: [crew_zone_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_zone_order_by!],
        "filter the rows returned"
        where: crew_zone_bool_exp
    ): [crew_zone!]!
    "fetch aggregated fields from the table: \"crew_zone\""
    crew_zone_aggregate(
        "distinct select on columns"
        distinct_on: [crew_zone_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_zone_order_by!],
        "filter the rows returned"
        where: crew_zone_bool_exp
    ): crew_zone_aggregate!
    "fetch data from the table: \"crew_zone\" using primary key columns"
    crew_zone_by_pk(id: uuid!): crew_zone
    "archive"
    delete(userId: String): deleteQuery
    "fetch data from the table: \"event_status\""
    event_status(
        "distinct select on columns"
        distinct_on: [event_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [event_status_order_by!],
        "filter the rows returned"
        where: event_status_bool_exp
    ): [event_status!]!
    "fetch aggregated fields from the table: \"event_status\""
    event_status_aggregate(
        "distinct select on columns"
        distinct_on: [event_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [event_status_order_by!],
        "filter the rows returned"
        where: event_status_bool_exp
    ): event_status_aggregate!
    "fetch data from the table: \"event_status\" using primary key columns"
    event_status_by_pk(value: String!): event_status
    "fetch data from the table: \"events\""
    events(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): [events!]!
    "fetch aggregated fields from the table: \"events\""
    events_aggregate(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): events_aggregate!
    "fetch data from the table: \"events\" using primary key columns"
    events_by_pk(id: uuid!): events
    "fetch data from the table: \"eventsdescription\""
    eventsdescription(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [eventsdescription_order_by!],
        "filter the rows returned"
        where: eventsdescription_bool_exp
    ): [eventsdescription!]!
    "fetch aggregated fields from the table: \"eventsdescription\""
    eventsdescription_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [eventsdescription_order_by!],
        "filter the rows returned"
        where: eventsdescription_bool_exp
    ): eventsdescription_aggregate!
    "fetch data from the table: \"eventsdescription\" using primary key columns"
    eventsdescription_by_pk(Id: Int!): eventsdescription
    "fetch data from the table: \"filters\""
    filters(
        "distinct select on columns"
        distinct_on: [filters_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [filters_order_by!],
        "filter the rows returned"
        where: filters_bool_exp
    ): [filters!]!
    "fetch aggregated fields from the table: \"filters\""
    filters_aggregate(
        "distinct select on columns"
        distinct_on: [filters_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [filters_order_by!],
        "filter the rows returned"
        where: filters_bool_exp
    ): filters_aggregate!
    "fetch data from the table: \"filters\" using primary key columns"
    filters_by_pk(Id: uuid!): filters
    "forgot"
    forgot(loginId: String!, sendForgotPasswordEmail: Boolean!): forgotOutput
    "get current user"
    getMe: UserOutput
    "get user by user UUID from FusionAuth"
    getUser(id: uuid!): UserOutput
    getUsersBy(role: String): usersQuery
    "Get users using QueryString that searches name, surname, email, username"
    getUsersByQueryString(queryString: String!): usersQuery
    "fusion auth  login"
    login(password: String!, username: String!): LoginOutput
    "fetch data from the table: \"events\""
    monas_events(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_events_order_by!],
        "filter the rows returned"
        where: monas_events_bool_exp
    ): [monas_events!]!
    "fetch aggregated fields from the table: \"events\""
    monas_events_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_events_order_by!],
        "filter the rows returned"
        where: monas_events_bool_exp
    ): monas_events_aggregate!
    "fetch data from the table: \"events\" using primary key columns"
    monas_events_by_pk(id: Int!): monas_events
    "fetch data from the table: \"objects\""
    monas_objects(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_objects_order_by!],
        "filter the rows returned"
        where: monas_objects_bool_exp
    ): [monas_objects!]!
    "fetch aggregated fields from the table: \"objects\""
    monas_objects_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_objects_order_by!],
        "filter the rows returned"
        where: monas_objects_bool_exp
    ): monas_objects_aggregate!
    "fetch data from the table: \"objects\" using primary key columns"
    monas_objects_by_pk(Id: Int!): monas_objects
    "fetch data from the table: \"monas_related\""
    monas_related(
        "distinct select on columns"
        distinct_on: [monas_related_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_related_order_by!],
        "filter the rows returned"
        where: monas_related_bool_exp
    ): [monas_related!]!
    "fetch aggregated fields from the table: \"monas_related\""
    monas_related_aggregate(
        "distinct select on columns"
        distinct_on: [monas_related_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_related_order_by!],
        "filter the rows returned"
        where: monas_related_bool_exp
    ): monas_related_aggregate!
    "fetch data from the table: \"monas_related\" using primary key columns"
    monas_related_by_pk(id: uuid!): monas_related
    "fetch data from the table: \"object\""
    object(
        "distinct select on columns"
        distinct_on: [object_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_order_by!],
        "filter the rows returned"
        where: object_bool_exp
    ): [object!]!
    "fetch aggregated fields from the table: \"object\""
    object_aggregate(
        "distinct select on columns"
        distinct_on: [object_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_order_by!],
        "filter the rows returned"
        where: object_bool_exp
    ): object_aggregate!
    "fetch data from the table: \"object\" using primary key columns"
    object_by_pk(id: uuid!): object
    "fetch data from the table: \"object_image\""
    object_image(
        "distinct select on columns"
        distinct_on: [object_image_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_image_order_by!],
        "filter the rows returned"
        where: object_image_bool_exp
    ): [object_image!]!
    "fetch aggregated fields from the table: \"object_image\""
    object_image_aggregate(
        "distinct select on columns"
        distinct_on: [object_image_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_image_order_by!],
        "filter the rows returned"
        where: object_image_bool_exp
    ): object_image_aggregate!
    "fetch data from the table: \"object_image\" using primary key columns"
    object_image_by_pk(id: uuid!): object_image
    "fetch data from the table: \"object_key\""
    object_key(
        "distinct select on columns"
        distinct_on: [object_key_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_order_by!],
        "filter the rows returned"
        where: object_key_bool_exp
    ): [object_key!]!
    "fetch aggregated fields from the table: \"object_key\""
    object_key_aggregate(
        "distinct select on columns"
        distinct_on: [object_key_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_order_by!],
        "filter the rows returned"
        where: object_key_bool_exp
    ): object_key_aggregate!
    "fetch data from the table: \"object_key_box\""
    object_key_box(
        "distinct select on columns"
        distinct_on: [object_key_box_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_box_order_by!],
        "filter the rows returned"
        where: object_key_box_bool_exp
    ): [object_key_box!]!
    "fetch aggregated fields from the table: \"object_key_box\""
    object_key_box_aggregate(
        "distinct select on columns"
        distinct_on: [object_key_box_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_box_order_by!],
        "filter the rows returned"
        where: object_key_box_bool_exp
    ): object_key_box_aggregate!
    "fetch data from the table: \"object_key_box\" using primary key columns"
    object_key_box_by_pk(id: uuid!): object_key_box
    "fetch data from the table: \"object_key\" using primary key columns"
    object_key_by_pk(id: uuid!): object_key
    "fetch data from the table: \"object_key_rels\""
    object_key_rels(
        "distinct select on columns"
        distinct_on: [object_key_rels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_rels_order_by!],
        "filter the rows returned"
        where: object_key_rels_bool_exp
    ): [object_key_rels!]!
    "fetch aggregated fields from the table: \"object_key_rels\""
    object_key_rels_aggregate(
        "distinct select on columns"
        distinct_on: [object_key_rels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_rels_order_by!],
        "filter the rows returned"
        where: object_key_rels_bool_exp
    ): object_key_rels_aggregate!
    "fetch data from the table: \"object_key_rels\" using primary key columns"
    object_key_rels_by_pk(box_id: uuid!, key_id: uuid!): object_key_rels
    "fetch data from the table: \"object_modem\""
    object_modem(
        "distinct select on columns"
        distinct_on: [object_modem_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_modem_order_by!],
        "filter the rows returned"
        where: object_modem_bool_exp
    ): [object_modem!]!
    "fetch aggregated fields from the table: \"object_modem\""
    object_modem_aggregate(
        "distinct select on columns"
        distinct_on: [object_modem_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_modem_order_by!],
        "filter the rows returned"
        where: object_modem_bool_exp
    ): object_modem_aggregate!
    "fetch data from the table: \"object_modem\" using primary key columns"
    object_modem_by_pk(id: uuid!): object_modem
    "fetch data from the table: \"object_user_rel\""
    object_user_rel(
        "distinct select on columns"
        distinct_on: [object_user_rel_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_user_rel_order_by!],
        "filter the rows returned"
        where: object_user_rel_bool_exp
    ): [object_user_rel!]!
    "fetch aggregated fields from the table: \"object_user_rel\""
    object_user_rel_aggregate(
        "distinct select on columns"
        distinct_on: [object_user_rel_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_user_rel_order_by!],
        "filter the rows returned"
        where: object_user_rel_bool_exp
    ): object_user_rel_aggregate!
    "fetch data from the table: \"object_user_rel\" using primary key columns"
    object_user_rel_by_pk(object_id: uuid!, user_id: uuid!): object_user_rel
    "fetch data from the table: \"objectimages\""
    objectimages(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [objectimages_order_by!],
        "filter the rows returned"
        where: objectimages_bool_exp
    ): [objectimages!]!
    "fetch aggregated fields from the table: \"objectimages\""
    objectimages_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [objectimages_order_by!],
        "filter the rows returned"
        where: objectimages_bool_exp
    ): objectimages_aggregate!
    "fetch data from the table: \"objectimages\" using primary key columns"
    objectimages_by_pk(Id: Int!): objectimages
    "fetch data from the table: \"provider\""
    provider(
        "distinct select on columns"
        distinct_on: [provider_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [provider_order_by!],
        "filter the rows returned"
        where: provider_bool_exp
    ): [provider!]!
    "fetch aggregated fields from the table: \"provider\""
    provider_aggregate(
        "distinct select on columns"
        distinct_on: [provider_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [provider_order_by!],
        "filter the rows returned"
        where: provider_bool_exp
    ): provider_aggregate!
    "fetch data from the table: \"provider\" using primary key columns"
    provider_by_pk(value: String!): provider
    "fetch data from the table: \"reason_for_cancellation\""
    reason_for_cancellation(
        "distinct select on columns"
        distinct_on: [reason_for_cancellation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reason_for_cancellation_order_by!],
        "filter the rows returned"
        where: reason_for_cancellation_bool_exp
    ): [reason_for_cancellation!]!
    "fetch aggregated fields from the table: \"reason_for_cancellation\""
    reason_for_cancellation_aggregate(
        "distinct select on columns"
        distinct_on: [reason_for_cancellation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reason_for_cancellation_order_by!],
        "filter the rows returned"
        where: reason_for_cancellation_bool_exp
    ): reason_for_cancellation_aggregate!
    "fetch data from the table: \"reason_for_cancellation\" using primary key columns"
    reason_for_cancellation_by_pk(value: String!): reason_for_cancellation
    "refresh"
    refresh(refreshToken: String!): refreshOutput
    register(birthDate: String, email: String!, firstName: String!, lastName: String!, mobilePhone: String!, password: String!, role: String!): loginOutput
    "remind"
    remind(changePasswordId: String!, password: String!): remindOutput
    "fetch data from the table: \"task_type\""
    task_type(
        "distinct select on columns"
        distinct_on: [task_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_type_order_by!],
        "filter the rows returned"
        where: task_type_bool_exp
    ): [task_type!]!
    "fetch aggregated fields from the table: \"task_type\""
    task_type_aggregate(
        "distinct select on columns"
        distinct_on: [task_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_type_order_by!],
        "filter the rows returned"
        where: task_type_bool_exp
    ): task_type_aggregate!
    "fetch data from the table: \"task_type\" using primary key columns"
    task_type_by_pk(value: String!): task_type
    "updateRegister"
    updateRegister(roles: String!, userId: String!): updateOutput
    "files"
    uploadImages(authToken: String!, id: String!, image: String!): uploadQuery
    "fetch data from the table: \"user_settings\""
    user_settings(
        "distinct select on columns"
        distinct_on: [user_settings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_settings_order_by!],
        "filter the rows returned"
        where: user_settings_bool_exp
    ): [user_settings!]!
    "fetch aggregated fields from the table: \"user_settings\""
    user_settings_aggregate(
        "distinct select on columns"
        distinct_on: [user_settings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_settings_order_by!],
        "filter the rows returned"
        where: user_settings_bool_exp
    ): user_settings_aggregate!
    "fetch data from the table: \"user_settings\" using primary key columns"
    user_settings_by_pk(id: Int!): user_settings
    "fetch data from the table: \"user_type\""
    user_type(
        "distinct select on columns"
        distinct_on: [user_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_type_order_by!],
        "filter the rows returned"
        where: user_type_bool_exp
    ): [user_type!]!
    "fetch aggregated fields from the table: \"user_type\""
    user_type_aggregate(
        "distinct select on columns"
        distinct_on: [user_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_type_order_by!],
        "filter the rows returned"
        where: user_type_bool_exp
    ): user_type_aggregate!
    "fetch data from the table: \"user_type\" using primary key columns"
    user_type_by_pk(value: String!): user_type
}

"columns and relationships of \"reason_for_cancellation\""
type reason_for_cancellation {
    comment: String
    value: String!
}

"aggregated selection of \"reason_for_cancellation\""
type reason_for_cancellation_aggregate {
    aggregate: reason_for_cancellation_aggregate_fields
    nodes: [reason_for_cancellation!]!
}

"aggregate fields of \"reason_for_cancellation\""
type reason_for_cancellation_aggregate_fields {
    count(columns: [reason_for_cancellation_select_column!], distinct: Boolean): Int!
    max: reason_for_cancellation_max_fields
    min: reason_for_cancellation_min_fields
}

"aggregate max on columns"
type reason_for_cancellation_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type reason_for_cancellation_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"reason_for_cancellation\""
type reason_for_cancellation_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [reason_for_cancellation!]!
}

type refreshOutput {
    refreshToken: String
    token: String
}

type remindOutput {
    refreshToken: String
    token: String
}

type subscription_root {
    "fetch data from the table: \"central\""
    central(
        "distinct select on columns"
        distinct_on: [central_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [central_order_by!],
        "filter the rows returned"
        where: central_bool_exp
    ): [central!]!
    "fetch aggregated fields from the table: \"central\""
    central_aggregate(
        "distinct select on columns"
        distinct_on: [central_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [central_order_by!],
        "filter the rows returned"
        where: central_bool_exp
    ): central_aggregate!
    "fetch data from the table: \"central\" using primary key columns"
    central_by_pk(value: String!): central
    "fetch data from the table: \"city\""
    city(
        "distinct select on columns"
        distinct_on: [city_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [city_order_by!],
        "filter the rows returned"
        where: city_bool_exp
    ): [city!]!
    "fetch aggregated fields from the table: \"city\""
    city_aggregate(
        "distinct select on columns"
        distinct_on: [city_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [city_order_by!],
        "filter the rows returned"
        where: city_bool_exp
    ): city_aggregate!
    "fetch data from the table: \"city\" using primary key columns"
    city_by_pk(value: String!): city
    "fetch data from the table: \"coresppersons\""
    coresppersons(
        "distinct select on columns"
        distinct_on: [coresppersons_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [coresppersons_order_by!],
        "filter the rows returned"
        where: coresppersons_bool_exp
    ): [coresppersons!]!
    "fetch aggregated fields from the table: \"coresppersons\""
    coresppersons_aggregate(
        "distinct select on columns"
        distinct_on: [coresppersons_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [coresppersons_order_by!],
        "filter the rows returned"
        where: coresppersons_bool_exp
    ): coresppersons_aggregate!
    "fetch data from the table: \"coresppersons\" using primary key columns"
    coresppersons_by_pk(id: String!): coresppersons
    "fetch data from the table: \"corresppersons\""
    corresppersons(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [corresppersons_order_by!],
        "filter the rows returned"
        where: corresppersons_bool_exp
    ): [corresppersons!]!
    "fetch aggregated fields from the table: \"corresppersons\""
    corresppersons_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [corresppersons_order_by!],
        "filter the rows returned"
        where: corresppersons_bool_exp
    ): corresppersons_aggregate!
    "fetch data from the table: \"corresppersons\" using primary key columns"
    corresppersons_by_pk(id: Int!): corresppersons
    "fetch data from the table: \"crew\""
    crew(
        "distinct select on columns"
        distinct_on: [crew_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_order_by!],
        "filter the rows returned"
        where: crew_bool_exp
    ): [crew!]!
    "fetch aggregated fields from the table: \"crew\""
    crew_aggregate(
        "distinct select on columns"
        distinct_on: [crew_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_order_by!],
        "filter the rows returned"
        where: crew_bool_exp
    ): crew_aggregate!
    "fetch data from the table: \"crew_breach\""
    crew_breach(
        "distinct select on columns"
        distinct_on: [crew_breach_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_breach_order_by!],
        "filter the rows returned"
        where: crew_breach_bool_exp
    ): [crew_breach!]!
    "fetch aggregated fields from the table: \"crew_breach\""
    crew_breach_aggregate(
        "distinct select on columns"
        distinct_on: [crew_breach_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_breach_order_by!],
        "filter the rows returned"
        where: crew_breach_bool_exp
    ): crew_breach_aggregate!
    "fetch data from the table: \"crew_breach\" using primary key columns"
    crew_breach_by_pk(id: uuid!): crew_breach
    "fetch data from the table: \"crew\" using primary key columns"
    crew_by_pk(id: uuid!): crew
    "fetch data from the table: \"crew_calendar\""
    crew_calendar(
        "distinct select on columns"
        distinct_on: [crew_calendar_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_calendar_order_by!],
        "filter the rows returned"
        where: crew_calendar_bool_exp
    ): [crew_calendar!]!
    "fetch aggregated fields from the table: \"crew_calendar\""
    crew_calendar_aggregate(
        "distinct select on columns"
        distinct_on: [crew_calendar_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_calendar_order_by!],
        "filter the rows returned"
        where: crew_calendar_bool_exp
    ): crew_calendar_aggregate!
    "fetch data from the table: \"crew_calendar\" using primary key columns"
    crew_calendar_by_pk(id: uuid!): crew_calendar
    "fetch data from the table: \"crew_driver\""
    crew_driver(
        "distinct select on columns"
        distinct_on: [crew_driver_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_driver_order_by!],
        "filter the rows returned"
        where: crew_driver_bool_exp
    ): [crew_driver!]!
    "fetch aggregated fields from the table: \"crew_driver\""
    crew_driver_aggregate(
        "distinct select on columns"
        distinct_on: [crew_driver_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_driver_order_by!],
        "filter the rows returned"
        where: crew_driver_bool_exp
    ): crew_driver_aggregate!
    "fetch data from the table: \"crew_driver\" using primary key columns"
    crew_driver_by_pk(id: uuid!): crew_driver
    "fetch data from the table: \"crew_permission\""
    crew_permission(
        "distinct select on columns"
        distinct_on: [crew_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_permission_order_by!],
        "filter the rows returned"
        where: crew_permission_bool_exp
    ): [crew_permission!]!
    "fetch aggregated fields from the table: \"crew_permission\""
    crew_permission_aggregate(
        "distinct select on columns"
        distinct_on: [crew_permission_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_permission_order_by!],
        "filter the rows returned"
        where: crew_permission_bool_exp
    ): crew_permission_aggregate!
    "fetch data from the table: \"crew_permission\" using primary key columns"
    crew_permission_by_pk(id: uuid!): crew_permission
    "fetch data from the table: \"crew_request\""
    crew_request(
        "distinct select on columns"
        distinct_on: [crew_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_request_order_by!],
        "filter the rows returned"
        where: crew_request_bool_exp
    ): [crew_request!]!
    "fetch aggregated fields from the table: \"crew_request\""
    crew_request_aggregate(
        "distinct select on columns"
        distinct_on: [crew_request_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_request_order_by!],
        "filter the rows returned"
        where: crew_request_bool_exp
    ): crew_request_aggregate!
    "fetch data from the table: \"crew_request\" using primary key columns"
    crew_request_by_pk(value: String!): crew_request
    "fetch data from the table: \"crew_request_status\""
    crew_request_status(
        "distinct select on columns"
        distinct_on: [crew_request_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_request_status_order_by!],
        "filter the rows returned"
        where: crew_request_status_bool_exp
    ): [crew_request_status!]!
    "fetch aggregated fields from the table: \"crew_request_status\""
    crew_request_status_aggregate(
        "distinct select on columns"
        distinct_on: [crew_request_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_request_status_order_by!],
        "filter the rows returned"
        where: crew_request_status_bool_exp
    ): crew_request_status_aggregate!
    "fetch data from the table: \"crew_request_status\" using primary key columns"
    crew_request_status_by_pk(value: String!): crew_request_status
    "fetch data from the table: \"crew_status\""
    crew_status(
        "distinct select on columns"
        distinct_on: [crew_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_status_order_by!],
        "filter the rows returned"
        where: crew_status_bool_exp
    ): [crew_status!]!
    "fetch aggregated fields from the table: \"crew_status\""
    crew_status_aggregate(
        "distinct select on columns"
        distinct_on: [crew_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_status_order_by!],
        "filter the rows returned"
        where: crew_status_bool_exp
    ): crew_status_aggregate!
    "fetch data from the table: \"crew_status\" using primary key columns"
    crew_status_by_pk(value: String!): crew_status
    "fetch data from the table: \"crew_zone\""
    crew_zone(
        "distinct select on columns"
        distinct_on: [crew_zone_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_zone_order_by!],
        "filter the rows returned"
        where: crew_zone_bool_exp
    ): [crew_zone!]!
    "fetch aggregated fields from the table: \"crew_zone\""
    crew_zone_aggregate(
        "distinct select on columns"
        distinct_on: [crew_zone_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [crew_zone_order_by!],
        "filter the rows returned"
        where: crew_zone_bool_exp
    ): crew_zone_aggregate!
    "fetch data from the table: \"crew_zone\" using primary key columns"
    crew_zone_by_pk(id: uuid!): crew_zone
    "fetch data from the table: \"event_status\""
    event_status(
        "distinct select on columns"
        distinct_on: [event_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [event_status_order_by!],
        "filter the rows returned"
        where: event_status_bool_exp
    ): [event_status!]!
    "fetch aggregated fields from the table: \"event_status\""
    event_status_aggregate(
        "distinct select on columns"
        distinct_on: [event_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [event_status_order_by!],
        "filter the rows returned"
        where: event_status_bool_exp
    ): event_status_aggregate!
    "fetch data from the table: \"event_status\" using primary key columns"
    event_status_by_pk(value: String!): event_status
    "fetch data from the table: \"events\""
    events(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): [events!]!
    "fetch aggregated fields from the table: \"events\""
    events_aggregate(
        "distinct select on columns"
        distinct_on: [events_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [events_order_by!],
        "filter the rows returned"
        where: events_bool_exp
    ): events_aggregate!
    "fetch data from the table: \"events\" using primary key columns"
    events_by_pk(id: uuid!): events
    "fetch data from the table: \"eventsdescription\""
    eventsdescription(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [eventsdescription_order_by!],
        "filter the rows returned"
        where: eventsdescription_bool_exp
    ): [eventsdescription!]!
    "fetch aggregated fields from the table: \"eventsdescription\""
    eventsdescription_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [eventsdescription_order_by!],
        "filter the rows returned"
        where: eventsdescription_bool_exp
    ): eventsdescription_aggregate!
    "fetch data from the table: \"eventsdescription\" using primary key columns"
    eventsdescription_by_pk(Id: Int!): eventsdescription
    "fetch data from the table: \"filters\""
    filters(
        "distinct select on columns"
        distinct_on: [filters_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [filters_order_by!],
        "filter the rows returned"
        where: filters_bool_exp
    ): [filters!]!
    "fetch aggregated fields from the table: \"filters\""
    filters_aggregate(
        "distinct select on columns"
        distinct_on: [filters_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [filters_order_by!],
        "filter the rows returned"
        where: filters_bool_exp
    ): filters_aggregate!
    "fetch data from the table: \"filters\" using primary key columns"
    filters_by_pk(Id: uuid!): filters
    "fetch data from the table: \"events\""
    monas_events(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_events_order_by!],
        "filter the rows returned"
        where: monas_events_bool_exp
    ): [monas_events!]!
    "fetch aggregated fields from the table: \"events\""
    monas_events_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_events_order_by!],
        "filter the rows returned"
        where: monas_events_bool_exp
    ): monas_events_aggregate!
    "fetch data from the table: \"events\" using primary key columns"
    monas_events_by_pk(id: Int!): monas_events
    "fetch data from the table: \"objects\""
    monas_objects(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_objects_order_by!],
        "filter the rows returned"
        where: monas_objects_bool_exp
    ): [monas_objects!]!
    "fetch aggregated fields from the table: \"objects\""
    monas_objects_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_objects_order_by!],
        "filter the rows returned"
        where: monas_objects_bool_exp
    ): monas_objects_aggregate!
    "fetch data from the table: \"objects\" using primary key columns"
    monas_objects_by_pk(Id: Int!): monas_objects
    "fetch data from the table: \"monas_related\""
    monas_related(
        "distinct select on columns"
        distinct_on: [monas_related_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_related_order_by!],
        "filter the rows returned"
        where: monas_related_bool_exp
    ): [monas_related!]!
    "fetch aggregated fields from the table: \"monas_related\""
    monas_related_aggregate(
        "distinct select on columns"
        distinct_on: [monas_related_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [monas_related_order_by!],
        "filter the rows returned"
        where: monas_related_bool_exp
    ): monas_related_aggregate!
    "fetch data from the table: \"monas_related\" using primary key columns"
    monas_related_by_pk(id: uuid!): monas_related
    "fetch data from the table: \"object\""
    object(
        "distinct select on columns"
        distinct_on: [object_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_order_by!],
        "filter the rows returned"
        where: object_bool_exp
    ): [object!]!
    "fetch aggregated fields from the table: \"object\""
    object_aggregate(
        "distinct select on columns"
        distinct_on: [object_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_order_by!],
        "filter the rows returned"
        where: object_bool_exp
    ): object_aggregate!
    "fetch data from the table: \"object\" using primary key columns"
    object_by_pk(id: uuid!): object
    "fetch data from the table: \"object_image\""
    object_image(
        "distinct select on columns"
        distinct_on: [object_image_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_image_order_by!],
        "filter the rows returned"
        where: object_image_bool_exp
    ): [object_image!]!
    "fetch aggregated fields from the table: \"object_image\""
    object_image_aggregate(
        "distinct select on columns"
        distinct_on: [object_image_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_image_order_by!],
        "filter the rows returned"
        where: object_image_bool_exp
    ): object_image_aggregate!
    "fetch data from the table: \"object_image\" using primary key columns"
    object_image_by_pk(id: uuid!): object_image
    "fetch data from the table: \"object_key\""
    object_key(
        "distinct select on columns"
        distinct_on: [object_key_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_order_by!],
        "filter the rows returned"
        where: object_key_bool_exp
    ): [object_key!]!
    "fetch aggregated fields from the table: \"object_key\""
    object_key_aggregate(
        "distinct select on columns"
        distinct_on: [object_key_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_order_by!],
        "filter the rows returned"
        where: object_key_bool_exp
    ): object_key_aggregate!
    "fetch data from the table: \"object_key_box\""
    object_key_box(
        "distinct select on columns"
        distinct_on: [object_key_box_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_box_order_by!],
        "filter the rows returned"
        where: object_key_box_bool_exp
    ): [object_key_box!]!
    "fetch aggregated fields from the table: \"object_key_box\""
    object_key_box_aggregate(
        "distinct select on columns"
        distinct_on: [object_key_box_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_box_order_by!],
        "filter the rows returned"
        where: object_key_box_bool_exp
    ): object_key_box_aggregate!
    "fetch data from the table: \"object_key_box\" using primary key columns"
    object_key_box_by_pk(id: uuid!): object_key_box
    "fetch data from the table: \"object_key\" using primary key columns"
    object_key_by_pk(id: uuid!): object_key
    "fetch data from the table: \"object_key_rels\""
    object_key_rels(
        "distinct select on columns"
        distinct_on: [object_key_rels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_rels_order_by!],
        "filter the rows returned"
        where: object_key_rels_bool_exp
    ): [object_key_rels!]!
    "fetch aggregated fields from the table: \"object_key_rels\""
    object_key_rels_aggregate(
        "distinct select on columns"
        distinct_on: [object_key_rels_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_key_rels_order_by!],
        "filter the rows returned"
        where: object_key_rels_bool_exp
    ): object_key_rels_aggregate!
    "fetch data from the table: \"object_key_rels\" using primary key columns"
    object_key_rels_by_pk(box_id: uuid!, key_id: uuid!): object_key_rels
    "fetch data from the table: \"object_modem\""
    object_modem(
        "distinct select on columns"
        distinct_on: [object_modem_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_modem_order_by!],
        "filter the rows returned"
        where: object_modem_bool_exp
    ): [object_modem!]!
    "fetch aggregated fields from the table: \"object_modem\""
    object_modem_aggregate(
        "distinct select on columns"
        distinct_on: [object_modem_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_modem_order_by!],
        "filter the rows returned"
        where: object_modem_bool_exp
    ): object_modem_aggregate!
    "fetch data from the table: \"object_modem\" using primary key columns"
    object_modem_by_pk(id: uuid!): object_modem
    "fetch data from the table: \"object_user_rel\""
    object_user_rel(
        "distinct select on columns"
        distinct_on: [object_user_rel_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_user_rel_order_by!],
        "filter the rows returned"
        where: object_user_rel_bool_exp
    ): [object_user_rel!]!
    "fetch aggregated fields from the table: \"object_user_rel\""
    object_user_rel_aggregate(
        "distinct select on columns"
        distinct_on: [object_user_rel_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [object_user_rel_order_by!],
        "filter the rows returned"
        where: object_user_rel_bool_exp
    ): object_user_rel_aggregate!
    "fetch data from the table: \"object_user_rel\" using primary key columns"
    object_user_rel_by_pk(object_id: uuid!, user_id: uuid!): object_user_rel
    "fetch data from the table: \"objectimages\""
    objectimages(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [objectimages_order_by!],
        "filter the rows returned"
        where: objectimages_bool_exp
    ): [objectimages!]!
    "fetch aggregated fields from the table: \"objectimages\""
    objectimages_aggregate(
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [objectimages_order_by!],
        "filter the rows returned"
        where: objectimages_bool_exp
    ): objectimages_aggregate!
    "fetch data from the table: \"objectimages\" using primary key columns"
    objectimages_by_pk(Id: Int!): objectimages
    "fetch data from the table: \"provider\""
    provider(
        "distinct select on columns"
        distinct_on: [provider_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [provider_order_by!],
        "filter the rows returned"
        where: provider_bool_exp
    ): [provider!]!
    "fetch aggregated fields from the table: \"provider\""
    provider_aggregate(
        "distinct select on columns"
        distinct_on: [provider_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [provider_order_by!],
        "filter the rows returned"
        where: provider_bool_exp
    ): provider_aggregate!
    "fetch data from the table: \"provider\" using primary key columns"
    provider_by_pk(value: String!): provider
    "fetch data from the table: \"reason_for_cancellation\""
    reason_for_cancellation(
        "distinct select on columns"
        distinct_on: [reason_for_cancellation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reason_for_cancellation_order_by!],
        "filter the rows returned"
        where: reason_for_cancellation_bool_exp
    ): [reason_for_cancellation!]!
    "fetch aggregated fields from the table: \"reason_for_cancellation\""
    reason_for_cancellation_aggregate(
        "distinct select on columns"
        distinct_on: [reason_for_cancellation_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [reason_for_cancellation_order_by!],
        "filter the rows returned"
        where: reason_for_cancellation_bool_exp
    ): reason_for_cancellation_aggregate!
    "fetch data from the table: \"reason_for_cancellation\" using primary key columns"
    reason_for_cancellation_by_pk(value: String!): reason_for_cancellation
    "fetch data from the table: \"task_type\""
    task_type(
        "distinct select on columns"
        distinct_on: [task_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_type_order_by!],
        "filter the rows returned"
        where: task_type_bool_exp
    ): [task_type!]!
    "fetch aggregated fields from the table: \"task_type\""
    task_type_aggregate(
        "distinct select on columns"
        distinct_on: [task_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_type_order_by!],
        "filter the rows returned"
        where: task_type_bool_exp
    ): task_type_aggregate!
    "fetch data from the table: \"task_type\" using primary key columns"
    task_type_by_pk(value: String!): task_type
    "fetch data from the table: \"user_settings\""
    user_settings(
        "distinct select on columns"
        distinct_on: [user_settings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_settings_order_by!],
        "filter the rows returned"
        where: user_settings_bool_exp
    ): [user_settings!]!
    "fetch aggregated fields from the table: \"user_settings\""
    user_settings_aggregate(
        "distinct select on columns"
        distinct_on: [user_settings_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_settings_order_by!],
        "filter the rows returned"
        where: user_settings_bool_exp
    ): user_settings_aggregate!
    "fetch data from the table: \"user_settings\" using primary key columns"
    user_settings_by_pk(id: Int!): user_settings
    "fetch data from the table: \"user_type\""
    user_type(
        "distinct select on columns"
        distinct_on: [user_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_type_order_by!],
        "filter the rows returned"
        where: user_type_bool_exp
    ): [user_type!]!
    "fetch aggregated fields from the table: \"user_type\""
    user_type_aggregate(
        "distinct select on columns"
        distinct_on: [user_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_type_order_by!],
        "filter the rows returned"
        where: user_type_bool_exp
    ): user_type_aggregate!
    "fetch data from the table: \"user_type\" using primary key columns"
    user_type_by_pk(value: String!): user_type
}

"columns and relationships of \"task_type\""
type task_type {
    comment: String
    value: String!
}

"aggregated selection of \"task_type\""
type task_type_aggregate {
    aggregate: task_type_aggregate_fields
    nodes: [task_type!]!
}

"aggregate fields of \"task_type\""
type task_type_aggregate_fields {
    count(columns: [task_type_select_column!], distinct: Boolean): Int!
    max: task_type_max_fields
    min: task_type_min_fields
}

"aggregate max on columns"
type task_type_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type task_type_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"task_type\""
type task_type_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [task_type!]!
}

type updateOutput {
    roles: String!
    userId: String!
}

type uploadQuery {
    authToken: String
    id: String
    image: String
}

"columns and relationships of \"user_settings\""
type user_settings {
    created_at: timestamptz!
    fusion_auth_id: uuid!
    id: Int!
    imei: String
    is_logged_in: Boolean
    updated_at: timestamptz!
}

"aggregated selection of \"user_settings\""
type user_settings_aggregate {
    aggregate: user_settings_aggregate_fields
    nodes: [user_settings!]!
}

"aggregate fields of \"user_settings\""
type user_settings_aggregate_fields {
    avg: user_settings_avg_fields
    count(columns: [user_settings_select_column!], distinct: Boolean): Int!
    max: user_settings_max_fields
    min: user_settings_min_fields
    stddev: user_settings_stddev_fields
    stddev_pop: user_settings_stddev_pop_fields
    stddev_samp: user_settings_stddev_samp_fields
    sum: user_settings_sum_fields
    var_pop: user_settings_var_pop_fields
    var_samp: user_settings_var_samp_fields
    variance: user_settings_variance_fields
}

"aggregate avg on columns"
type user_settings_avg_fields {
    id: Float
}

"aggregate max on columns"
type user_settings_max_fields {
    created_at: timestamptz
    fusion_auth_id: uuid
    id: Int
    imei: String
    updated_at: timestamptz
}

"aggregate min on columns"
type user_settings_min_fields {
    created_at: timestamptz
    fusion_auth_id: uuid
    id: Int
    imei: String
    updated_at: timestamptz
}

"response of any mutation on the table \"user_settings\""
type user_settings_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_settings!]!
}

"aggregate stddev on columns"
type user_settings_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type user_settings_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type user_settings_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type user_settings_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type user_settings_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type user_settings_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type user_settings_variance_fields {
    id: Float
}

"columns and relationships of \"user_type\""
type user_type {
    comment: String!
    value: String!
}

"aggregated selection of \"user_type\""
type user_type_aggregate {
    aggregate: user_type_aggregate_fields
    nodes: [user_type!]!
}

"aggregate fields of \"user_type\""
type user_type_aggregate_fields {
    count(columns: [user_type_select_column!], distinct: Boolean): Int!
    max: user_type_max_fields
    min: user_type_min_fields
}

"aggregate max on columns"
type user_type_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type user_type_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"user_type\""
type user_type_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_type!]!
}

type usersQuery {
    users: [UserObject]
}

"unique or primary key constraints on table \"central\""
enum central_constraint {
    "unique or primary key constraint"
    central_pkey
}

enum central_enum {
    SEKOLINK
}

"select columns of table \"central\""
enum central_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"central\""
enum central_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"city\""
enum city_constraint {
    "unique or primary key constraint"
    city_pkey
}

enum city_enum {
    JONAVA
    KAUNAS
    UTENA
    VILNIUS
}

"select columns of table \"city\""
enum city_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"city\""
enum city_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"coresppersons\""
enum coresppersons_constraint {
    "unique or primary key constraint"
    monas_coresppersons_related_pkey
}

"select columns of table \"coresppersons\""
enum coresppersons_select_column {
    "column name"
    Id
    "column name"
    SendMail
    "column name"
    SendSMS
    "column name"
    ShowAtWorkTimeOnly
    "column name"
    address
    "column name"
    category
    "column name"
    deleted
    "column name"
    email
    "column name"
    id
    "column name"
    index
    "column name"
    key
    "column name"
    letConnect
    "column name"
    letSeeInvoices
    "column name"
    name
    "column name"
    notes
    "column name"
    objectid
    "column name"
    office
    "column name"
    onvacationfrom
    "column name"
    onvacationto
    "column name"
    personid
    "column name"
    phone
    "column name"
    phone2
    "column name"
    phone3
    "column name"
    position
}

"update columns of table \"coresppersons\""
enum coresppersons_update_column {
    "column name"
    Id
    "column name"
    SendMail
    "column name"
    SendSMS
    "column name"
    ShowAtWorkTimeOnly
    "column name"
    address
    "column name"
    category
    "column name"
    deleted
    "column name"
    email
    "column name"
    id
    "column name"
    index
    "column name"
    key
    "column name"
    letConnect
    "column name"
    letSeeInvoices
    "column name"
    name
    "column name"
    notes
    "column name"
    objectid
    "column name"
    office
    "column name"
    onvacationfrom
    "column name"
    onvacationto
    "column name"
    personid
    "column name"
    phone
    "column name"
    phone2
    "column name"
    phone3
    "column name"
    position
}

"select match_columns of table \"corresppersons\""
enum corresppersons_insert_match_column {
    "column name"
    SendMail
    "column name"
    SendSMS
    "column name"
    ShowAtWorkTimeOnly
    "column name"
    address
    "column name"
    category
    "column name"
    email
    "column name"
    id
    "column name"
    key
    "column name"
    name
    "column name"
    notes
    "column name"
    objectid
    "column name"
    office
    "column name"
    onvacationfrom
    "column name"
    onvacationto
    "column name"
    personid
    "column name"
    phone
    "column name"
    phone2
    "column name"
    phone3
    "column name"
    position
}

"select columns of table \"corresppersons\""
enum corresppersons_select_column {
    "column name"
    SendMail
    "column name"
    SendSMS
    "column name"
    ShowAtWorkTimeOnly
    "column name"
    address
    "column name"
    category
    "column name"
    email
    "column name"
    id
    "column name"
    key
    "column name"
    name
    "column name"
    notes
    "column name"
    objectid
    "column name"
    office
    "column name"
    onvacationfrom
    "column name"
    onvacationto
    "column name"
    personid
    "column name"
    phone
    "column name"
    phone2
    "column name"
    phone3
    "column name"
    position
}

"update columns of table \"corresppersons\""
enum corresppersons_update_column {
    "column name"
    SendMail
    "column name"
    SendSMS
    "column name"
    ShowAtWorkTimeOnly
    "column name"
    address
    "column name"
    category
    "column name"
    email
    "column name"
    key
    "column name"
    name
    "column name"
    notes
    "column name"
    objectid
    "column name"
    office
    "column name"
    onvacationfrom
    "column name"
    onvacationto
    "column name"
    personid
    "column name"
    phone
    "column name"
    phone2
    "column name"
    phone3
    "column name"
    position
}

"unique or primary key constraints on table \"crew_breach\""
enum crew_breach_constraint {
    "unique or primary key constraint"
    breach_crew_id_key
    "unique or primary key constraint"
    breach_driver_id_key
    "unique or primary key constraint"
    breach_pkey
}

"select columns of table \"crew_breach\""
enum crew_breach_select_column {
    "column name"
    crew_id
    "column name"
    driver_id
    "column name"
    end_time
    "column name"
    id
    "column name"
    nodes
    "column name"
    start_time
}

"update columns of table \"crew_breach\""
enum crew_breach_update_column {
    "column name"
    crew_id
    "column name"
    driver_id
    "column name"
    end_time
    "column name"
    id
    "column name"
    nodes
    "column name"
    start_time
}

"unique or primary key constraints on table \"crew_calendar\""
enum crew_calendar_constraint {
    "unique or primary key constraint"
    crew_calendar_dislocation_zone_id_key
    "unique or primary key constraint"
    crew_calendar_pkey
}

"select columns of table \"crew_calendar\""
enum crew_calendar_select_column {
    "column name"
    created_at
    "column name"
    crew_id
    "column name"
    dislocation_zone_id
    "column name"
    end_time
    "column name"
    id
    "column name"
    start_time
    "column name"
    updated_at
    "column name"
    week_day
}

"update columns of table \"crew_calendar\""
enum crew_calendar_update_column {
    "column name"
    created_at
    "column name"
    crew_id
    "column name"
    dislocation_zone_id
    "column name"
    end_time
    "column name"
    id
    "column name"
    start_time
    "column name"
    updated_at
    "column name"
    week_day
}

"unique or primary key constraints on table \"crew\""
enum crew_constraint {
    "unique or primary key constraint"
    monas_crew_related_pkey
}

"unique or primary key constraints on table \"crew_driver\""
enum crew_driver_constraint {
    "unique or primary key constraint"
    crew_driver_pkey
}

"select columns of table \"crew_driver\""
enum crew_driver_select_column {
    "column name"
    created_at
    "column name"
    crew_id
    "column name"
    id
    "column name"
    updated_at
}

"update columns of table \"crew_driver\""
enum crew_driver_update_column {
    "column name"
    created_at
    "column name"
    crew_id
    "column name"
    id
    "column name"
    updated_at
}

"unique or primary key constraints on table \"crew_permission\""
enum crew_permission_constraint {
    "unique or primary key constraint"
    crew_permission_pkey
}

"select columns of table \"crew_permission\""
enum crew_permission_select_column {
    "column name"
    comment
    "column name"
    created_at
    "column name"
    crew_id
    "column name"
    id
    "column name"
    request_id
    "column name"
    status
    "column name"
    updated_at
}

"update columns of table \"crew_permission\""
enum crew_permission_update_column {
    "column name"
    comment
    "column name"
    created_at
    "column name"
    crew_id
    "column name"
    id
    "column name"
    request_id
    "column name"
    status
    "column name"
    updated_at
}

"unique or primary key constraints on table \"crew_request\""
enum crew_request_constraint {
    "unique or primary key constraint"
    crew_request_pkey1
}

"select columns of table \"crew_request\""
enum crew_request_select_column {
    "column name"
    duration
    "column name"
    value
}

"unique or primary key constraints on table \"crew_request_status\""
enum crew_request_status_constraint {
    "unique or primary key constraint"
    crew_request_pkey
}

enum crew_request_status_enum {
    ALLOWED
    ASKED
    COMPLETE
    REJECTED
}

"select columns of table \"crew_request_status\""
enum crew_request_status_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"crew_request_status\""
enum crew_request_status_update_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"crew_request\""
enum crew_request_update_column {
    "column name"
    duration
    "column name"
    value
}

"select columns of table \"crew\""
enum crew_select_column {
    "column name"
    driver_name
    "column name"
    id
    "column name"
    is_assigned_automatically
    "column name"
    is_assigned_while_in_breaks
    "column name"
    name
    "column name"
    phone_number
    "column name"
    status
    "column name"
    to_call_after
}

"unique or primary key constraints on table \"crew_status\""
enum crew_status_constraint {
    "unique or primary key constraint"
    crew_status_pkey
}

enum crew_status_enum {
    BREAK
    BUSY
    OFFLINE
    READY
}

"select columns of table \"crew_status\""
enum crew_status_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"crew_status\""
enum crew_status_update_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"crew\""
enum crew_update_column {
    "column name"
    driver_name
    "column name"
    id
    "column name"
    is_assigned_automatically
    "column name"
    is_assigned_while_in_breaks
    "column name"
    name
    "column name"
    phone_number
    "column name"
    status
    "column name"
    to_call_after
}

"unique or primary key constraints on table \"crew_zone\""
enum crew_zone_constraint {
    "unique or primary key constraint"
    crew_zones_pkey
}

"select columns of table \"crew_zone\""
enum crew_zone_select_column {
    "column name"
    crew_id
    "column name"
    id
    "column name"
    name
    "column name"
    nodes
}

"update columns of table \"crew_zone\""
enum crew_zone_update_column {
    "column name"
    crew_id
    "column name"
    id
    "column name"
    name
    "column name"
    nodes
}

"unique or primary key constraints on table \"event_status\""
enum event_status_constraint {
    "unique or primary key constraint"
    event_status_pkey
}

enum event_status_enum {
    ALARMING
    CANCELED
    INSPECTION
    INSPECTION_DONE
    WAITING_FOR_INSPECTION
}

"select columns of table \"event_status\""
enum event_status_select_column {
    "column name"
    description
    "column name"
    value
}

"update columns of table \"event_status\""
enum event_status_update_column {
    "column name"
    description
    "column name"
    value
}

"unique or primary key constraints on table \"events\""
enum events_constraint {
    "unique or primary key constraint"
    events_crew_id_key
    "unique or primary key constraint"
    events_pkey
}

"select columns of table \"events\""
enum events_select_column {
    "column name"
    created_at
    "column name"
    crew_id
    "column name"
    description
    "column name"
    id
    "column name"
    name
    "column name"
    object_id
    "column name"
    provider_id
    "column name"
    provider_name
    "column name"
    status
    "column name"
    updated_at
}

"update columns of table \"events\""
enum events_update_column {
    "column name"
    created_at
    "column name"
    crew_id
    "column name"
    description
    "column name"
    id
    "column name"
    name
    "column name"
    object_id
    "column name"
    provider_id
    "column name"
    provider_name
    "column name"
    status
    "column name"
    updated_at
}

"select match_columns of table \"eventsdescription\""
enum eventsdescription_insert_match_column {
    "column name"
    Id
    "column name"
    SMSid
    "column name"
    SMSsender
    "column name"
    SendMail
    "column name"
    SendSMS
    "column name"
    SendSMStoPerson
    "column name"
    SendViaTCP
    "column name"
    clasificator
    "column name"
    eMailId
    "column name"
    exampleid
    "column name"
    expireAfter
    "column name"
    forward
    "column name"
    forwardedobjectid
    "column name"
    isRestoreEvent
    "column name"
    limit_sms
    "column name"
    name
    "column name"
    objectnr
    "column name"
    reaction
    "column name"
    relationID
    "column name"
    seekRestore
    "column name"
    sms_limit_time
    "column name"
    sound
    "column name"
    useinterval
    "column name"
    value
    "column name"
    valuefrom
    "column name"
    valueto
    "column name"
    window
    "column name"
    zonenr
}

"select columns of table \"eventsdescription\""
enum eventsdescription_select_column {
    "column name"
    Id
    "column name"
    SMSid
    "column name"
    SMSsender
    "column name"
    SendMail
    "column name"
    SendSMS
    "column name"
    SendSMStoPerson
    "column name"
    SendViaTCP
    "column name"
    clasificator
    "column name"
    eMailId
    "column name"
    exampleid
    "column name"
    expireAfter
    "column name"
    forward
    "column name"
    forwardedobjectid
    "column name"
    isRestoreEvent
    "column name"
    limit_sms
    "column name"
    name
    "column name"
    objectnr
    "column name"
    reaction
    "column name"
    relationID
    "column name"
    seekRestore
    "column name"
    sms_limit_time
    "column name"
    sound
    "column name"
    useinterval
    "column name"
    value
    "column name"
    valuefrom
    "column name"
    valueto
    "column name"
    window
    "column name"
    zonenr
}

"update columns of table \"eventsdescription\""
enum eventsdescription_update_column {
    "column name"
    SMSid
    "column name"
    SMSsender
    "column name"
    SendMail
    "column name"
    SendSMS
    "column name"
    SendSMStoPerson
    "column name"
    SendViaTCP
    "column name"
    clasificator
    "column name"
    eMailId
    "column name"
    exampleid
    "column name"
    expireAfter
    "column name"
    forward
    "column name"
    forwardedobjectid
    "column name"
    isRestoreEvent
    "column name"
    limit_sms
    "column name"
    name
    "column name"
    objectnr
    "column name"
    reaction
    "column name"
    relationID
    "column name"
    seekRestore
    "column name"
    sms_limit_time
    "column name"
    sound
    "column name"
    useinterval
    "column name"
    value
    "column name"
    valuefrom
    "column name"
    valueto
    "column name"
    window
    "column name"
    zonenr
}

"unique or primary key constraints on table \"filters\""
enum filters_constraint {
    "unique or primary key constraint"
    filters_pkey
}

"select columns of table \"filters\""
enum filters_select_column {
    "column name"
    Id
    "column name"
    crew
    "column name"
    dashboardList
    "column name"
    date
    "column name"
    driver
    "column name"
    filterName
    "column name"
    filterShortName
    "column name"
    group
    "column name"
    id
    "column name"
    inTime
    "column name"
    object
    "column name"
    objectAddress
    "column name"
    operator
    "column name"
    reason
    "column name"
    savedToFavorite
    "column name"
    savedToMenu
    "column name"
    status
    "column name"
    type
    "column name"
    userId
}

"update columns of table \"filters\""
enum filters_update_column {
    "column name"
    Id
    "column name"
    crew
    "column name"
    dashboardList
    "column name"
    date
    "column name"
    driver
    "column name"
    filterName
    "column name"
    filterShortName
    "column name"
    group
    "column name"
    id
    "column name"
    inTime
    "column name"
    object
    "column name"
    objectAddress
    "column name"
    operator
    "column name"
    reason
    "column name"
    savedToFavorite
    "column name"
    savedToMenu
    "column name"
    status
    "column name"
    type
    "column name"
    userId
}

"select match_columns of table \"events\""
enum monas_events_insert_match_column {
    "column name"
    ObjectName
    "column name"
    Remind
    "column name"
    RemindAtTime
    "column name"
    RemindFromTime
    "column name"
    RemindInHours
    "column name"
    RemindInMinutes
    "column name"
    Reminder
    "column name"
    action
    "column name"
    addedtoarchivetime
    "column name"
    clasificator
    "column name"
    closedby
    "column name"
    eventcode
    "column name"
    eventdescid
    "column name"
    eventname
    "column name"
    eventsource
    "column name"
    groupnr
    "column name"
    id
    "column name"
    linename
    "column name"
    linenr
    "column name"
    lockedby
    "column name"
    objectdbid
    "column name"
    objectnr
    "column name"
    playsound
    "column name"
    priority
    "column name"
    reactedby
    "column name"
    reactedtime
    "column name"
    reactionid
    "column name"
    reactiontype
    "column name"
    receivedlevel
    "column name"
    receivedtime
    "column name"
    receivername
    "column name"
    receivernr
    "column name"
    relationid
    "column name"
    repeated
    "column name"
    retranslator
    "column name"
    retranslatorlevel
    "column name"
    selectable
    "column name"
    status
    "column name"
    unifier_id
    "column name"
    wasDriverAcquired
    "column name"
    zonenumber
}

"select columns of table \"events\""
enum monas_events_select_column {
    "column name"
    ObjectName
    "column name"
    Remind
    "column name"
    RemindAtTime
    "column name"
    RemindFromTime
    "column name"
    RemindInHours
    "column name"
    RemindInMinutes
    "column name"
    Reminder
    "column name"
    action
    "column name"
    addedtoarchivetime
    "column name"
    clasificator
    "column name"
    closedby
    "column name"
    eventcode
    "column name"
    eventdescid
    "column name"
    eventname
    "column name"
    eventsource
    "column name"
    groupnr
    "column name"
    id
    "column name"
    linename
    "column name"
    linenr
    "column name"
    lockedby
    "column name"
    objectdbid
    "column name"
    objectnr
    "column name"
    playsound
    "column name"
    priority
    "column name"
    reactedby
    "column name"
    reactedtime
    "column name"
    reactionid
    "column name"
    reactiontype
    "column name"
    receivedlevel
    "column name"
    receivedtime
    "column name"
    receivername
    "column name"
    receivernr
    "column name"
    relationid
    "column name"
    repeated
    "column name"
    retranslator
    "column name"
    retranslatorlevel
    "column name"
    selectable
    "column name"
    status
    "column name"
    unifier_id
    "column name"
    wasDriverAcquired
    "column name"
    zonenumber
}

"update columns of table \"events\""
enum monas_events_update_column {
    "column name"
    ObjectName
    "column name"
    Remind
    "column name"
    RemindAtTime
    "column name"
    RemindFromTime
    "column name"
    RemindInHours
    "column name"
    RemindInMinutes
    "column name"
    Reminder
    "column name"
    action
    "column name"
    addedtoarchivetime
    "column name"
    clasificator
    "column name"
    closedby
    "column name"
    eventcode
    "column name"
    eventdescid
    "column name"
    eventname
    "column name"
    eventsource
    "column name"
    groupnr
    "column name"
    linename
    "column name"
    linenr
    "column name"
    lockedby
    "column name"
    objectdbid
    "column name"
    objectnr
    "column name"
    playsound
    "column name"
    priority
    "column name"
    reactedby
    "column name"
    reactedtime
    "column name"
    reactionid
    "column name"
    reactiontype
    "column name"
    receivedlevel
    "column name"
    receivedtime
    "column name"
    receivername
    "column name"
    receivernr
    "column name"
    relationid
    "column name"
    repeated
    "column name"
    retranslator
    "column name"
    retranslatorlevel
    "column name"
    selectable
    "column name"
    status
    "column name"
    unifier_id
    "column name"
    wasDriverAcquired
    "column name"
    zonenumber
}

"select match_columns of table \"objects\""
enum monas_objects_insert_match_column {
    "column name"
    AcLossDetected
    "column name"
    DcLossDetected
    "column name"
    Id
    "column name"
    Locked
    "column name"
    MainSubDisabled
    "column name"
    MainSubDriverReactionTimes
    "column name"
    MainSubEvents
    "column name"
    MainSubGenerated
    "column name"
    MainSubId
    "column name"
    MainSubInfo
    "column name"
    MainSubMoreNotes
    "column name"
    MainSubOpenClose
    "column name"
    MainSubPersons
    "column name"
    MainSubSchemes
    "column name"
    MainSubTest
    "column name"
    MainSubZones
    "column name"
    NotesText
    "column name"
    OpenCloseSeekState
    "column name"
    TS
    "column name"
    address
    "column name"
    assignedeventexampleid
    "column name"
    assignedgroupableeventexampleid
    "column name"
    celebrationsclosehour
    "column name"
    celebrationsclosemin
    "column name"
    celebrationsopenhour
    "column name"
    celebrationsopenmin
    "column name"
    city
    "column name"
    closedeviation
    "column name"
    closedeviationneg
    "column name"
    closehourdefault
    "column name"
    closemindefault
    "column name"
    contract
    "column name"
    contract2
    "column name"
    destination
    "column name"
    dynamic
    "column name"
    firsttest
    "column name"
    freeEvents
    "column name"
    fridayclosehour
    "column name"
    fridayclosemin
    "column name"
    fridayopenhour
    "column name"
    fridayopenmin
    "column name"
    generatedeventsexample
    "column name"
    grg_info
    "column name"
    groupid
    "column name"
    installed
    "column name"
    installer
    "column name"
    installerCompany
    "column name"
    intlinenr
    "column name"
    intreceivernr
    "column name"
    lastPersonToOpenClose
    "column name"
    lasttesttime
    "column name"
    latitude
    "column name"
    linenr
    "column name"
    longitude
    "column name"
    mainsubgroup
    "column name"
    mondayclosehour
    "column name"
    mondayclosemin
    "column name"
    mondayopenhour
    "column name"
    mondayopenmin
    "column name"
    mustopen
    "column name"
    name
    "column name"
    notes
    "column name"
    obdindx
    "column name"
    objectid
    "column name"
    objectstate
    "column name"
    objectstatus
    "column name"
    opendeviation
    "column name"
    opendeviationneg
    "column name"
    openhourdefault
    "column name"
    openmindefault
    "column name"
    otherevents
    "column name"
    phone
    "column name"
    reacttoeachevent
    "column name"
    receivernr
    "column name"
    region
    "column name"
    relationId
    "column name"
    saturdayclosehour
    "column name"
    saturdayclosemin
    "column name"
    saturdayopenhour
    "column name"
    saturdayopenmin
    "column name"
    seekcelebrationsclose
    "column name"
    seekcelebrationsopen
    "column name"
    seekcloseworktime
    "column name"
    seekfridayclose
    "column name"
    seekfridayopen
    "column name"
    seekmondayclose
    "column name"
    seekmondayopen
    "column name"
    seekopenworktime
    "column name"
    seeksaturdayclose
    "column name"
    seeksaturdayopen
    "column name"
    seeksundayclose
    "column name"
    seeksundayopen
    "column name"
    seekthursdayclose
    "column name"
    seekthursdayopen
    "column name"
    seektuesdayclose
    "column name"
    seektuesdayopen
    "column name"
    seekwednesdayclose
    "column name"
    seekwednesdayopen
    "column name"
    specialcelebrations
    "column name"
    specialfriday
    "column name"
    specialmonday
    "column name"
    specialsaturday
    "column name"
    specialsunday
    "column name"
    specialthursday
    "column name"
    specialtuesday
    "column name"
    specialwednesday
    "column name"
    street
    "column name"
    subdivision
    "column name"
    subgroup
    "column name"
    sundayclosehour
    "column name"
    sundayclosemin
    "column name"
    sundayopenhour
    "column name"
    sundayopenmin
    "column name"
    synchronize
    "column name"
    testtype
    "column name"
    thursdayclosehour
    "column name"
    thursdayclosemin
    "column name"
    thursdayopenhour
    "column name"
    thursdayopenmin
    "column name"
    timebetweentestdays
    "column name"
    timebetweentesttime
    "column name"
    timesperday
    "column name"
    timestamp
    "column name"
    tolerance
    "column name"
    transinstdate
    "column name"
    tuesdayclosehour
    "column name"
    tuesdayclosemin
    "column name"
    tuesdayopenhour
    "column name"
    tuesdayopenmin
    "column name"
    unifier_id
    "column name"
    uniqueID
    "column name"
    useeventexample
    "column name"
    usegroupableeventsexample
    "column name"
    wednesdayclosehour
    "column name"
    wednesdayclosemin
    "column name"
    wednesdayopenhour
    "column name"
    wednesdayopenmin
}

"select columns of table \"objects\""
enum monas_objects_select_column {
    "column name"
    AcLossDetected
    "column name"
    DcLossDetected
    "column name"
    Id
    "column name"
    Locked
    "column name"
    MainSubDisabled
    "column name"
    MainSubDriverReactionTimes
    "column name"
    MainSubEvents
    "column name"
    MainSubGenerated
    "column name"
    MainSubId
    "column name"
    MainSubInfo
    "column name"
    MainSubMoreNotes
    "column name"
    MainSubOpenClose
    "column name"
    MainSubPersons
    "column name"
    MainSubSchemes
    "column name"
    MainSubTest
    "column name"
    MainSubZones
    "column name"
    NotesText
    "column name"
    OpenCloseSeekState
    "column name"
    TS
    "column name"
    address
    "column name"
    assignedeventexampleid
    "column name"
    assignedgroupableeventexampleid
    "column name"
    celebrationsclosehour
    "column name"
    celebrationsclosemin
    "column name"
    celebrationsopenhour
    "column name"
    celebrationsopenmin
    "column name"
    city
    "column name"
    closedeviation
    "column name"
    closedeviationneg
    "column name"
    closehourdefault
    "column name"
    closemindefault
    "column name"
    contract
    "column name"
    contract2
    "column name"
    destination
    "column name"
    dynamic
    "column name"
    firsttest
    "column name"
    freeEvents
    "column name"
    fridayclosehour
    "column name"
    fridayclosemin
    "column name"
    fridayopenhour
    "column name"
    fridayopenmin
    "column name"
    generatedeventsexample
    "column name"
    grg_info
    "column name"
    groupid
    "column name"
    installed
    "column name"
    installer
    "column name"
    installerCompany
    "column name"
    intlinenr
    "column name"
    intreceivernr
    "column name"
    lastPersonToOpenClose
    "column name"
    lasttesttime
    "column name"
    latitude
    "column name"
    linenr
    "column name"
    longitude
    "column name"
    mainsubgroup
    "column name"
    mondayclosehour
    "column name"
    mondayclosemin
    "column name"
    mondayopenhour
    "column name"
    mondayopenmin
    "column name"
    mustopen
    "column name"
    name
    "column name"
    notes
    "column name"
    obdindx
    "column name"
    objectid
    "column name"
    objectstate
    "column name"
    objectstatus
    "column name"
    opendeviation
    "column name"
    opendeviationneg
    "column name"
    openhourdefault
    "column name"
    openmindefault
    "column name"
    otherevents
    "column name"
    phone
    "column name"
    reacttoeachevent
    "column name"
    receivernr
    "column name"
    region
    "column name"
    relationId
    "column name"
    saturdayclosehour
    "column name"
    saturdayclosemin
    "column name"
    saturdayopenhour
    "column name"
    saturdayopenmin
    "column name"
    seekcelebrationsclose
    "column name"
    seekcelebrationsopen
    "column name"
    seekcloseworktime
    "column name"
    seekfridayclose
    "column name"
    seekfridayopen
    "column name"
    seekmondayclose
    "column name"
    seekmondayopen
    "column name"
    seekopenworktime
    "column name"
    seeksaturdayclose
    "column name"
    seeksaturdayopen
    "column name"
    seeksundayclose
    "column name"
    seeksundayopen
    "column name"
    seekthursdayclose
    "column name"
    seekthursdayopen
    "column name"
    seektuesdayclose
    "column name"
    seektuesdayopen
    "column name"
    seekwednesdayclose
    "column name"
    seekwednesdayopen
    "column name"
    specialcelebrations
    "column name"
    specialfriday
    "column name"
    specialmonday
    "column name"
    specialsaturday
    "column name"
    specialsunday
    "column name"
    specialthursday
    "column name"
    specialtuesday
    "column name"
    specialwednesday
    "column name"
    street
    "column name"
    subdivision
    "column name"
    subgroup
    "column name"
    sundayclosehour
    "column name"
    sundayclosemin
    "column name"
    sundayopenhour
    "column name"
    sundayopenmin
    "column name"
    synchronize
    "column name"
    testtype
    "column name"
    thursdayclosehour
    "column name"
    thursdayclosemin
    "column name"
    thursdayopenhour
    "column name"
    thursdayopenmin
    "column name"
    timebetweentestdays
    "column name"
    timebetweentesttime
    "column name"
    timesperday
    "column name"
    timestamp
    "column name"
    tolerance
    "column name"
    transinstdate
    "column name"
    tuesdayclosehour
    "column name"
    tuesdayclosemin
    "column name"
    tuesdayopenhour
    "column name"
    tuesdayopenmin
    "column name"
    unifier_id
    "column name"
    uniqueID
    "column name"
    useeventexample
    "column name"
    usegroupableeventsexample
    "column name"
    wednesdayclosehour
    "column name"
    wednesdayclosemin
    "column name"
    wednesdayopenhour
    "column name"
    wednesdayopenmin
}

"update columns of table \"objects\""
enum monas_objects_update_column {
    "column name"
    AcLossDetected
    "column name"
    DcLossDetected
    "column name"
    Locked
    "column name"
    MainSubDisabled
    "column name"
    MainSubDriverReactionTimes
    "column name"
    MainSubEvents
    "column name"
    MainSubGenerated
    "column name"
    MainSubId
    "column name"
    MainSubInfo
    "column name"
    MainSubMoreNotes
    "column name"
    MainSubOpenClose
    "column name"
    MainSubPersons
    "column name"
    MainSubSchemes
    "column name"
    MainSubTest
    "column name"
    MainSubZones
    "column name"
    NotesText
    "column name"
    OpenCloseSeekState
    "column name"
    TS
    "column name"
    address
    "column name"
    assignedeventexampleid
    "column name"
    assignedgroupableeventexampleid
    "column name"
    celebrationsclosehour
    "column name"
    celebrationsclosemin
    "column name"
    celebrationsopenhour
    "column name"
    celebrationsopenmin
    "column name"
    city
    "column name"
    closedeviation
    "column name"
    closedeviationneg
    "column name"
    closehourdefault
    "column name"
    closemindefault
    "column name"
    contract
    "column name"
    contract2
    "column name"
    destination
    "column name"
    dynamic
    "column name"
    firsttest
    "column name"
    freeEvents
    "column name"
    fridayclosehour
    "column name"
    fridayclosemin
    "column name"
    fridayopenhour
    "column name"
    fridayopenmin
    "column name"
    generatedeventsexample
    "column name"
    grg_info
    "column name"
    groupid
    "column name"
    installed
    "column name"
    installer
    "column name"
    installerCompany
    "column name"
    intlinenr
    "column name"
    intreceivernr
    "column name"
    lastPersonToOpenClose
    "column name"
    lasttesttime
    "column name"
    latitude
    "column name"
    linenr
    "column name"
    longitude
    "column name"
    mainsubgroup
    "column name"
    mondayclosehour
    "column name"
    mondayclosemin
    "column name"
    mondayopenhour
    "column name"
    mondayopenmin
    "column name"
    mustopen
    "column name"
    name
    "column name"
    notes
    "column name"
    obdindx
    "column name"
    objectid
    "column name"
    objectstate
    "column name"
    objectstatus
    "column name"
    opendeviation
    "column name"
    opendeviationneg
    "column name"
    openhourdefault
    "column name"
    openmindefault
    "column name"
    otherevents
    "column name"
    phone
    "column name"
    reacttoeachevent
    "column name"
    receivernr
    "column name"
    region
    "column name"
    relationId
    "column name"
    saturdayclosehour
    "column name"
    saturdayclosemin
    "column name"
    saturdayopenhour
    "column name"
    saturdayopenmin
    "column name"
    seekcelebrationsclose
    "column name"
    seekcelebrationsopen
    "column name"
    seekcloseworktime
    "column name"
    seekfridayclose
    "column name"
    seekfridayopen
    "column name"
    seekmondayclose
    "column name"
    seekmondayopen
    "column name"
    seekopenworktime
    "column name"
    seeksaturdayclose
    "column name"
    seeksaturdayopen
    "column name"
    seeksundayclose
    "column name"
    seeksundayopen
    "column name"
    seekthursdayclose
    "column name"
    seekthursdayopen
    "column name"
    seektuesdayclose
    "column name"
    seektuesdayopen
    "column name"
    seekwednesdayclose
    "column name"
    seekwednesdayopen
    "column name"
    specialcelebrations
    "column name"
    specialfriday
    "column name"
    specialmonday
    "column name"
    specialsaturday
    "column name"
    specialsunday
    "column name"
    specialthursday
    "column name"
    specialtuesday
    "column name"
    specialwednesday
    "column name"
    street
    "column name"
    subdivision
    "column name"
    subgroup
    "column name"
    sundayclosehour
    "column name"
    sundayclosemin
    "column name"
    sundayopenhour
    "column name"
    sundayopenmin
    "column name"
    synchronize
    "column name"
    testtype
    "column name"
    thursdayclosehour
    "column name"
    thursdayclosemin
    "column name"
    thursdayopenhour
    "column name"
    thursdayopenmin
    "column name"
    timebetweentestdays
    "column name"
    timebetweentesttime
    "column name"
    timesperday
    "column name"
    timestamp
    "column name"
    tolerance
    "column name"
    transinstdate
    "column name"
    tuesdayclosehour
    "column name"
    tuesdayclosemin
    "column name"
    tuesdayopenhour
    "column name"
    tuesdayopenmin
    "column name"
    unifier_id
    "column name"
    uniqueID
    "column name"
    useeventexample
    "column name"
    usegroupableeventsexample
    "column name"
    wednesdayclosehour
    "column name"
    wednesdayclosemin
    "column name"
    wednesdayopenhour
    "column name"
    wednesdayopenmin
}

"unique or primary key constraints on table \"monas_related\""
enum monas_related_constraint {
    "unique or primary key constraint"
    test_pkey
}

"select columns of table \"monas_related\""
enum monas_related_select_column {
    "column name"
    Id
    "column name"
    area_no
    "column name"
    assign_car
    "column name"
    atm
    "column name"
    contact
    "column name"
    id
    "column name"
    image
    "column name"
    imagename
    "column name"
    modem
    "column name"
    monasid
    "column name"
    navid
    "column name"
    object_contract
    "column name"
    object_key
    "column name"
    send_crew
}

"update columns of table \"monas_related\""
enum monas_related_update_column {
    "column name"
    Id
    "column name"
    area_no
    "column name"
    assign_car
    "column name"
    atm
    "column name"
    contact
    "column name"
    id
    "column name"
    image
    "column name"
    imagename
    "column name"
    modem
    "column name"
    monasid
    "column name"
    navid
    "column name"
    object_contract
    "column name"
    object_key
    "column name"
    send_crew
}

"unique or primary key constraints on table \"object\""
enum object_constraint {
    "unique or primary key constraint"
    object_id_key
    "unique or primary key constraint"
    object_pkey
    "unique or primary key constraint"
    object_provider_id_provider_name_key
}

"unique or primary key constraints on table \"object_image\""
enum object_image_constraint {
    "unique or primary key constraint"
    object_image_pkey
}

"select columns of table \"object_image\""
enum object_image_select_column {
    "column name"
    id
    "column name"
    object_id
    "column name"
    src
}

"update columns of table \"object_image\""
enum object_image_update_column {
    "column name"
    id
    "column name"
    object_id
    "column name"
    src
}

"unique or primary key constraints on table \"object_key_box\""
enum object_key_box_constraint {
    "unique or primary key constraint"
    object_key_box_pkey
}

"select columns of table \"object_key_box\""
enum object_key_box_select_column {
    "column name"
    crew_id
    "column name"
    id
    "column name"
    set_name
}

"update columns of table \"object_key_box\""
enum object_key_box_update_column {
    "column name"
    crew_id
    "column name"
    id
    "column name"
    set_name
}

"unique or primary key constraints on table \"object_key\""
enum object_key_constraint {
    "unique or primary key constraint"
    object_key_pkey
}

"unique or primary key constraints on table \"object_key_rels\""
enum object_key_rels_constraint {
    "unique or primary key constraint"
    object_key_rels_object_id_key_id_key
    "unique or primary key constraint"
    object_key_rels_pkey
}

"select columns of table \"object_key_rels\""
enum object_key_rels_select_column {
    "column name"
    box_id
    "column name"
    id
    "column name"
    key_id
    "column name"
    object_id
}

"update columns of table \"object_key_rels\""
enum object_key_rels_update_column {
    "column name"
    box_id
    "column name"
    id
    "column name"
    key_id
    "column name"
    object_id
}

"select columns of table \"object_key\""
enum object_key_select_column {
    "column name"
    crew_id
    "column name"
    id
    "column name"
    set_name
}

"update columns of table \"object_key\""
enum object_key_update_column {
    "column name"
    crew_id
    "column name"
    id
    "column name"
    set_name
}

"unique or primary key constraints on table \"object_modem\""
enum object_modem_constraint {
    "unique or primary key constraint"
    object_modem_pkey
}

"select columns of table \"object_modem\""
enum object_modem_select_column {
    "column name"
    area_no
    "column name"
    central
    "column name"
    id
    "column name"
    object_id
}

"update columns of table \"object_modem\""
enum object_modem_update_column {
    "column name"
    area_no
    "column name"
    central
    "column name"
    id
    "column name"
    object_id
}

"select columns of table \"object\""
enum object_select_column {
    "column name"
    address
    "column name"
    city
    "column name"
    contract_no
    "column name"
    contract_object_no
    "column name"
    description
    "column name"
    id
    "column name"
    is_atm
    "column name"
    is_crew_autoasigned
    "column name"
    latitude
    "column name"
    longitude
    "column name"
    name
    "column name"
    navision_id
    "column name"
    phone
    "column name"
    provider_id
    "column name"
    provider_name
}

"update columns of table \"object\""
enum object_update_column {
    "column name"
    address
    "column name"
    city
    "column name"
    contract_no
    "column name"
    contract_object_no
    "column name"
    description
    "column name"
    id
    "column name"
    is_atm
    "column name"
    is_crew_autoasigned
    "column name"
    latitude
    "column name"
    longitude
    "column name"
    name
    "column name"
    navision_id
    "column name"
    phone
    "column name"
    provider_id
    "column name"
    provider_name
}

"unique or primary key constraints on table \"object_user_rel\""
enum object_user_rel_constraint {
    "unique or primary key constraint"
    object_user_rel_pkey
    "unique or primary key constraint"
    object_user_rel_user_id_object_id_key
}

"select columns of table \"object_user_rel\""
enum object_user_rel_select_column {
    "column name"
    is_subscribed_yesterdays_report
    "column name"
    object_id
    "column name"
    user_id
    "column name"
    user_type
}

"update columns of table \"object_user_rel\""
enum object_user_rel_update_column {
    "column name"
    is_subscribed_yesterdays_report
    "column name"
    object_id
    "column name"
    user_id
    "column name"
    user_type
}

"select match_columns of table \"objectimages\""
enum objectimages_insert_match_column {
    "column name"
    Id
    "column name"
    defaultimage
    "column name"
    image
    "column name"
    imagename
    "column name"
    objectid
}

"select columns of table \"objectimages\""
enum objectimages_select_column {
    "column name"
    Id
    "column name"
    defaultimage
    "column name"
    image
    "column name"
    imagename
    "column name"
    objectid
}

"update columns of table \"objectimages\""
enum objectimages_update_column {
    "column name"
    defaultimage
    "column name"
    image
    "column name"
    imagename
    "column name"
    objectid
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"provider\""
enum provider_constraint {
    "unique or primary key constraint"
    provider_pkey
}

enum provider_enum {
    MONAS
    PROVIDER_2
}

"select columns of table \"provider\""
enum provider_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"provider\""
enum provider_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"reason_for_cancellation\""
enum reason_for_cancellation_constraint {
    "unique or primary key constraint"
    reason_for_cancellation_pkey
}

"select columns of table \"reason_for_cancellation\""
enum reason_for_cancellation_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"reason_for_cancellation\""
enum reason_for_cancellation_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"task_type\""
enum task_type_constraint {
    "unique or primary key constraint"
    task_type_pkey
}

"select columns of table \"task_type\""
enum task_type_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"task_type\""
enum task_type_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"user_settings\""
enum user_settings_constraint {
    "unique or primary key constraint"
    user_settings_fusion_auth_id_key
    "unique or primary key constraint"
    user_settings_imei_key
    "unique or primary key constraint"
    user_settings_pkey
}

"select columns of table \"user_settings\""
enum user_settings_select_column {
    "column name"
    created_at
    "column name"
    fusion_auth_id
    "column name"
    id
    "column name"
    imei
    "column name"
    is_logged_in
    "column name"
    updated_at
}

"update columns of table \"user_settings\""
enum user_settings_update_column {
    "column name"
    created_at
    "column name"
    fusion_auth_id
    "column name"
    id
    "column name"
    imei
    "column name"
    is_logged_in
    "column name"
    updated_at
}

"unique or primary key constraints on table \"user_type\""
enum user_type_constraint {
    "unique or primary key constraint"
    user_type_pkey
}

enum user_type_enum {
    COMPANY_ADMIN
}

"select columns of table \"user_type\""
enum user_type_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"user_type\""
enum user_type_update_column {
    "column name"
    comment
    "column name"
    value
}

scalar binary

scalar date

scalar datetime

scalar datetime2

scalar interval

scalar json

scalar jsonb

scalar numeric

scalar time

scalar timestamp

scalar timestamptz

scalar uniqueidentifier

scalar uuid

scalar varbinary

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_MSSQL_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Float\". All fields are combined with logical 'AND'."
input Float_MSSQL_comparison_exp {
    _eq: Float
    _gt: Float
    _gte: Float
    _in: [Float!]
    _is_null: Boolean
    _lt: Float
    _lte: Float
    _neq: Float
    _nin: [Float!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_MSSQL_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_MSSQL_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    _in: [String!]
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    _nin: [String!]
    "does the column NOT match the given pattern"
    _nlike: String
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

"Boolean expression to compare columns of type \"binary\". All fields are combined with logical 'AND'."
input binary_MSSQL_comparison_exp {
    _eq: binary
    _gt: binary
    _gte: binary
    _in: [binary!]
    _is_null: Boolean
    _lt: binary
    _lte: binary
    _neq: binary
    _nin: [binary!]
}

"Boolean expression to filter rows from the table \"central\". All fields are combined with a logical 'AND'."
input central_bool_exp {
    _and: [central_bool_exp!]
    _not: central_bool_exp
    _or: [central_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"central_enum\". All fields are combined with logical 'AND'."
input central_enum_comparison_exp {
    _eq: central_enum
    _in: [central_enum!]
    _is_null: Boolean
    _neq: central_enum
    _nin: [central_enum!]
}

"input type for inserting data into table \"central\""
input central_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"central\""
input central_on_conflict {
    constraint: central_constraint!
    update_columns: [central_update_column!]! = []
    where: central_bool_exp
}

"Ordering options when selecting data from \"central\"."
input central_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: central"
input central_pk_columns_input {
    value: String!
}

"input type for updating data in table \"central\""
input central_set_input {
    comment: String
    value: String
}

"Boolean expression to filter rows from the table \"city\". All fields are combined with a logical 'AND'."
input city_bool_exp {
    _and: [city_bool_exp!]
    _not: city_bool_exp
    _or: [city_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"city_enum\". All fields are combined with logical 'AND'."
input city_enum_comparison_exp {
    _eq: city_enum
    _in: [city_enum!]
    _is_null: Boolean
    _neq: city_enum
    _nin: [city_enum!]
}

"input type for inserting data into table \"city\""
input city_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"city\""
input city_on_conflict {
    constraint: city_constraint!
    update_columns: [city_update_column!]! = []
    where: city_bool_exp
}

"Ordering options when selecting data from \"city\"."
input city_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: city"
input city_pk_columns_input {
    value: String!
}

"input type for updating data in table \"city\""
input city_set_input {
    comment: String
    value: String
}

"Boolean expression to filter rows from the table \"coresppersons\". All fields are combined with a logical 'AND'."
input coresppersons_bool_exp {
    Id: String_comparison_exp
    SendMail: String_comparison_exp
    SendSMS: String_comparison_exp
    ShowAtWorkTimeOnly: String_comparison_exp
    _and: [coresppersons_bool_exp!]
    _not: coresppersons_bool_exp
    _or: [coresppersons_bool_exp!]
    address: String_comparison_exp
    category: Int_comparison_exp
    deleted: Boolean_comparison_exp
    email: String_comparison_exp
    id: String_comparison_exp
    index: Int_comparison_exp
    key: String_comparison_exp
    letConnect: Boolean_comparison_exp
    letSeeInvoices: Boolean_comparison_exp
    name: String_comparison_exp
    notes: String_comparison_exp
    objectid: Int_comparison_exp
    office: String_comparison_exp
    onvacationfrom: String_comparison_exp
    onvacationto: String_comparison_exp
    personid: Int_comparison_exp
    phone: String_comparison_exp
    phone2: String_comparison_exp
    phone3: String_comparison_exp
    position: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"coresppersons\""
input coresppersons_inc_input {
    category: Int
    index: Int
    objectid: Int
    personid: Int
    position: Int
}

"input type for inserting data into table \"coresppersons\""
input coresppersons_insert_input {
    Id: String
    SendMail: String
    SendSMS: String
    ShowAtWorkTimeOnly: String
    address: String
    category: Int
    deleted: Boolean
    email: String
    id: String
    index: Int
    key: String
    letConnect: Boolean
    letSeeInvoices: Boolean
    name: String
    notes: String
    objectid: Int
    office: String
    onvacationfrom: String
    onvacationto: String
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int
}

"on_conflict condition type for table \"coresppersons\""
input coresppersons_on_conflict {
    constraint: coresppersons_constraint!
    update_columns: [coresppersons_update_column!]! = []
    where: coresppersons_bool_exp
}

"Ordering options when selecting data from \"coresppersons\"."
input coresppersons_order_by {
    Id: order_by
    SendMail: order_by
    SendSMS: order_by
    ShowAtWorkTimeOnly: order_by
    address: order_by
    category: order_by
    deleted: order_by
    email: order_by
    id: order_by
    index: order_by
    key: order_by
    letConnect: order_by
    letSeeInvoices: order_by
    name: order_by
    notes: order_by
    objectid: order_by
    office: order_by
    onvacationfrom: order_by
    onvacationto: order_by
    personid: order_by
    phone: order_by
    phone2: order_by
    phone3: order_by
    position: order_by
}

"primary key columns input for table: coresppersons"
input coresppersons_pk_columns_input {
    id: String!
}

"input type for updating data in table \"coresppersons\""
input coresppersons_set_input {
    Id: String
    SendMail: String
    SendSMS: String
    ShowAtWorkTimeOnly: String
    address: String
    category: Int
    deleted: Boolean
    email: String
    id: String
    index: Int
    key: String
    letConnect: Boolean
    letSeeInvoices: Boolean
    name: String
    notes: String
    objectid: Int
    office: String
    onvacationfrom: String
    onvacationto: String
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int
}

"Boolean expression to filter rows from the table \"corresppersons\". All fields are combined with a logical 'AND'."
input corresppersons_bool_exp {
    SendMail: String_MSSQL_comparison_exp
    SendSMS: String_MSSQL_comparison_exp
    ShowAtWorkTimeOnly: String_MSSQL_comparison_exp
    _and: [corresppersons_bool_exp!]
    _not: corresppersons_bool_exp
    _or: [corresppersons_bool_exp!]
    address: String_MSSQL_comparison_exp
    category: Int_MSSQL_comparison_exp
    email: String_MSSQL_comparison_exp
    id: Int_MSSQL_comparison_exp
    key: String_MSSQL_comparison_exp
    name: String_MSSQL_comparison_exp
    notes: String_MSSQL_comparison_exp
    objectid: Int_MSSQL_comparison_exp
    office: String_MSSQL_comparison_exp
    onvacationfrom: datetime_MSSQL_comparison_exp
    onvacationto: datetime_MSSQL_comparison_exp
    personid: Int_MSSQL_comparison_exp
    phone: String_MSSQL_comparison_exp
    phone2: String_MSSQL_comparison_exp
    phone3: String_MSSQL_comparison_exp
    position: Int_MSSQL_comparison_exp
}

"upsert condition type for table \"corresppersons\""
input corresppersons_if_matched {
    match_columns: [corresppersons_insert_match_column!]! = []
    update_columns: [corresppersons_update_column!]! = []
    where: corresppersons_bool_exp
}

"input type for incrementing numeric columns in table \"corresppersons\""
input corresppersons_inc_input {
    category: Int
    objectid: Int
    personid: Int
    position: Int
}

"input type for inserting data into table \"corresppersons\""
input corresppersons_insert_input {
    SendMail: String
    SendSMS: String
    ShowAtWorkTimeOnly: String
    address: String
    category: Int
    email: String
    key: String
    name: String
    notes: String
    objectid: Int
    office: String
    onvacationfrom: datetime
    onvacationto: datetime
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int
}

"Ordering options when selecting data from \"corresppersons\"."
input corresppersons_order_by {
    SendMail: order_by
    SendSMS: order_by
    ShowAtWorkTimeOnly: order_by
    address: order_by
    category: order_by
    email: order_by
    id: order_by
    key: order_by
    name: order_by
    notes: order_by
    objectid: order_by
    office: order_by
    onvacationfrom: order_by
    onvacationto: order_by
    personid: order_by
    phone: order_by
    phone2: order_by
    phone3: order_by
    position: order_by
}

"primary key columns input for table: corresppersons"
input corresppersons_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"corresppersons\""
input corresppersons_set_input {
    SendMail: String
    SendSMS: String
    ShowAtWorkTimeOnly: String
    address: String
    category: Int
    email: String
    key: String
    name: String
    notes: String
    objectid: Int
    office: String
    onvacationfrom: datetime
    onvacationto: datetime
    personid: Int
    phone: String
    phone2: String
    phone3: String
    position: Int
}

"Boolean expression to filter rows from the table \"crew\". All fields are combined with a logical 'AND'."
input crew_bool_exp {
    _and: [crew_bool_exp!]
    _not: crew_bool_exp
    _or: [crew_bool_exp!]
    breaches: crew_breach_bool_exp
    calendar: crew_calendar_bool_exp
    driver_name: String_comparison_exp
    id: uuid_comparison_exp
    is_assigned_automatically: Boolean_comparison_exp
    is_assigned_while_in_breaks: Boolean_comparison_exp
    name: String_comparison_exp
    permissions: crew_permission_bool_exp
    phone_number: String_comparison_exp
    status: crew_status_enum_comparison_exp
    to_call_after: String_comparison_exp
    zone: crew_zone_bool_exp
}

"Boolean expression to filter rows from the table \"crew_breach\". All fields are combined with a logical 'AND'."
input crew_breach_bool_exp {
    _and: [crew_breach_bool_exp!]
    _not: crew_breach_bool_exp
    _or: [crew_breach_bool_exp!]
    crew: crew_bool_exp
    crew_id: uuid_comparison_exp
    driver_id: uuid_comparison_exp
    end_time: timestamptz_comparison_exp
    id: uuid_comparison_exp
    nodes: json_comparison_exp
    start_time: timestamptz_comparison_exp
}

"input type for inserting data into table \"crew_breach\""
input crew_breach_insert_input {
    crew: crew_obj_rel_insert_input
    crew_id: uuid
    driver_id: uuid
    end_time: timestamptz
    id: uuid
    nodes: json
    start_time: timestamptz
}

"input type for inserting object relation for remote table \"crew_breach\""
input crew_breach_obj_rel_insert_input {
    data: crew_breach_insert_input!
    "upsert condition"
    on_conflict: crew_breach_on_conflict
}

"on_conflict condition type for table \"crew_breach\""
input crew_breach_on_conflict {
    constraint: crew_breach_constraint!
    update_columns: [crew_breach_update_column!]! = []
    where: crew_breach_bool_exp
}

"Ordering options when selecting data from \"crew_breach\"."
input crew_breach_order_by {
    crew: crew_order_by
    crew_id: order_by
    driver_id: order_by
    end_time: order_by
    id: order_by
    nodes: order_by
    start_time: order_by
}

"primary key columns input for table: crew_breach"
input crew_breach_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"crew_breach\""
input crew_breach_set_input {
    crew_id: uuid
    driver_id: uuid
    end_time: timestamptz
    id: uuid
    nodes: json
    start_time: timestamptz
}

"Boolean expression to filter rows from the table \"crew_calendar\". All fields are combined with a logical 'AND'."
input crew_calendar_bool_exp {
    _and: [crew_calendar_bool_exp!]
    _not: crew_calendar_bool_exp
    _or: [crew_calendar_bool_exp!]
    created_at: timestamptz_comparison_exp
    crew: crew_bool_exp
    crew_id: uuid_comparison_exp
    dislocation_zone_id: uuid_comparison_exp
    end_time: interval_comparison_exp
    id: uuid_comparison_exp
    start_time: interval_comparison_exp
    updated_at: timestamptz_comparison_exp
    week_day: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"crew_calendar\""
input crew_calendar_inc_input {
    week_day: Int
}

"input type for inserting data into table \"crew_calendar\""
input crew_calendar_insert_input {
    created_at: timestamptz
    crew: crew_obj_rel_insert_input
    crew_id: uuid
    dislocation_zone_id: uuid
    end_time: interval
    id: uuid
    start_time: interval
    updated_at: timestamptz
    week_day: Int
}

"input type for inserting object relation for remote table \"crew_calendar\""
input crew_calendar_obj_rel_insert_input {
    data: crew_calendar_insert_input!
    "upsert condition"
    on_conflict: crew_calendar_on_conflict
}

"on_conflict condition type for table \"crew_calendar\""
input crew_calendar_on_conflict {
    constraint: crew_calendar_constraint!
    update_columns: [crew_calendar_update_column!]! = []
    where: crew_calendar_bool_exp
}

"Ordering options when selecting data from \"crew_calendar\"."
input crew_calendar_order_by {
    created_at: order_by
    crew: crew_order_by
    crew_id: order_by
    dislocation_zone_id: order_by
    end_time: order_by
    id: order_by
    start_time: order_by
    updated_at: order_by
    week_day: order_by
}

"primary key columns input for table: crew_calendar"
input crew_calendar_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"crew_calendar\""
input crew_calendar_set_input {
    created_at: timestamptz
    crew_id: uuid
    dislocation_zone_id: uuid
    end_time: interval
    id: uuid
    start_time: interval
    updated_at: timestamptz
    week_day: Int
}

"Boolean expression to filter rows from the table \"crew_driver\". All fields are combined with a logical 'AND'."
input crew_driver_bool_exp {
    _and: [crew_driver_bool_exp!]
    _not: crew_driver_bool_exp
    _or: [crew_driver_bool_exp!]
    created_at: timestamptz_comparison_exp
    crew_id: uuid_comparison_exp
    id: uuid_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"crew_driver\""
input crew_driver_insert_input {
    created_at: timestamptz
    crew_id: uuid
    id: uuid
    updated_at: timestamptz
}

"on_conflict condition type for table \"crew_driver\""
input crew_driver_on_conflict {
    constraint: crew_driver_constraint!
    update_columns: [crew_driver_update_column!]! = []
    where: crew_driver_bool_exp
}

"Ordering options when selecting data from \"crew_driver\"."
input crew_driver_order_by {
    created_at: order_by
    crew_id: order_by
    id: order_by
    updated_at: order_by
}

"primary key columns input for table: crew_driver"
input crew_driver_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"crew_driver\""
input crew_driver_set_input {
    created_at: timestamptz
    crew_id: uuid
    id: uuid
    updated_at: timestamptz
}

"input type for inserting data into table \"crew\""
input crew_insert_input {
    breaches: crew_breach_obj_rel_insert_input
    calendar: crew_calendar_obj_rel_insert_input
    driver_name: String
    id: uuid
    is_assigned_automatically: Boolean
    is_assigned_while_in_breaks: Boolean
    name: String
    permissions: crew_permission_arr_rel_insert_input
    phone_number: String
    status: crew_status_enum
    to_call_after: String
    zone: crew_zone_arr_rel_insert_input
}

"input type for inserting object relation for remote table \"crew\""
input crew_obj_rel_insert_input {
    data: crew_insert_input!
    "upsert condition"
    on_conflict: crew_on_conflict
}

"on_conflict condition type for table \"crew\""
input crew_on_conflict {
    constraint: crew_constraint!
    update_columns: [crew_update_column!]! = []
    where: crew_bool_exp
}

"Ordering options when selecting data from \"crew\"."
input crew_order_by {
    breaches: crew_breach_order_by
    calendar: crew_calendar_order_by
    driver_name: order_by
    id: order_by
    is_assigned_automatically: order_by
    is_assigned_while_in_breaks: order_by
    name: order_by
    permissions_aggregate: crew_permission_aggregate_order_by
    phone_number: order_by
    status: order_by
    to_call_after: order_by
    zone_aggregate: crew_zone_aggregate_order_by
}

"order by aggregate values of table \"crew_permission\""
input crew_permission_aggregate_order_by {
    count: order_by
    max: crew_permission_max_order_by
    min: crew_permission_min_order_by
}

"input type for inserting array relation for remote table \"crew_permission\""
input crew_permission_arr_rel_insert_input {
    data: [crew_permission_insert_input!]!
    "upsert condition"
    on_conflict: crew_permission_on_conflict
}

"Boolean expression to filter rows from the table \"crew_permission\". All fields are combined with a logical 'AND'."
input crew_permission_bool_exp {
    _and: [crew_permission_bool_exp!]
    _not: crew_permission_bool_exp
    _or: [crew_permission_bool_exp!]
    comment: String_comparison_exp
    created_at: timestamptz_comparison_exp
    crew: crew_bool_exp
    crew_id: uuid_comparison_exp
    id: uuid_comparison_exp
    request: crew_request_bool_exp
    request_id: String_comparison_exp
    status: crew_request_status_enum_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for inserting data into table \"crew_permission\""
input crew_permission_insert_input {
    comment: String
    created_at: timestamptz
    crew: crew_obj_rel_insert_input
    crew_id: uuid
    id: uuid
    request: crew_request_obj_rel_insert_input
    request_id: String
    status: crew_request_status_enum
    updated_at: timestamptz
}

"order by max() on columns of table \"crew_permission\""
input crew_permission_max_order_by {
    comment: order_by
    created_at: order_by
    crew_id: order_by
    id: order_by
    request_id: order_by
    updated_at: order_by
}

"order by min() on columns of table \"crew_permission\""
input crew_permission_min_order_by {
    comment: order_by
    created_at: order_by
    crew_id: order_by
    id: order_by
    request_id: order_by
    updated_at: order_by
}

"on_conflict condition type for table \"crew_permission\""
input crew_permission_on_conflict {
    constraint: crew_permission_constraint!
    update_columns: [crew_permission_update_column!]! = []
    where: crew_permission_bool_exp
}

"Ordering options when selecting data from \"crew_permission\"."
input crew_permission_order_by {
    comment: order_by
    created_at: order_by
    crew: crew_order_by
    crew_id: order_by
    id: order_by
    request: crew_request_order_by
    request_id: order_by
    status: order_by
    updated_at: order_by
}

"primary key columns input for table: crew_permission"
input crew_permission_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"crew_permission\""
input crew_permission_set_input {
    comment: String
    created_at: timestamptz
    crew_id: uuid
    id: uuid
    request_id: String
    status: crew_request_status_enum
    updated_at: timestamptz
}

"primary key columns input for table: crew"
input crew_pk_columns_input {
    id: uuid!
}

"Boolean expression to filter rows from the table \"crew_request\". All fields are combined with a logical 'AND'."
input crew_request_bool_exp {
    _and: [crew_request_bool_exp!]
    _not: crew_request_bool_exp
    _or: [crew_request_bool_exp!]
    duration: interval_comparison_exp
    permissions: crew_permission_bool_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"crew_request\""
input crew_request_insert_input {
    duration: interval
    permissions: crew_permission_arr_rel_insert_input
    value: String
}

"input type for inserting object relation for remote table \"crew_request\""
input crew_request_obj_rel_insert_input {
    data: crew_request_insert_input!
    "upsert condition"
    on_conflict: crew_request_on_conflict
}

"on_conflict condition type for table \"crew_request\""
input crew_request_on_conflict {
    constraint: crew_request_constraint!
    update_columns: [crew_request_update_column!]! = []
    where: crew_request_bool_exp
}

"Ordering options when selecting data from \"crew_request\"."
input crew_request_order_by {
    duration: order_by
    permissions_aggregate: crew_permission_aggregate_order_by
    value: order_by
}

"primary key columns input for table: crew_request"
input crew_request_pk_columns_input {
    value: String!
}

"input type for updating data in table \"crew_request\""
input crew_request_set_input {
    duration: interval
    value: String
}

"Boolean expression to filter rows from the table \"crew_request_status\". All fields are combined with a logical 'AND'."
input crew_request_status_bool_exp {
    _and: [crew_request_status_bool_exp!]
    _not: crew_request_status_bool_exp
    _or: [crew_request_status_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"crew_request_status_enum\". All fields are combined with logical 'AND'."
input crew_request_status_enum_comparison_exp {
    _eq: crew_request_status_enum
    _in: [crew_request_status_enum!]
    _is_null: Boolean
    _neq: crew_request_status_enum
    _nin: [crew_request_status_enum!]
}

"input type for inserting data into table \"crew_request_status\""
input crew_request_status_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"crew_request_status\""
input crew_request_status_on_conflict {
    constraint: crew_request_status_constraint!
    update_columns: [crew_request_status_update_column!]! = []
    where: crew_request_status_bool_exp
}

"Ordering options when selecting data from \"crew_request_status\"."
input crew_request_status_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: crew_request_status"
input crew_request_status_pk_columns_input {
    value: String!
}

"input type for updating data in table \"crew_request_status\""
input crew_request_status_set_input {
    comment: String
    value: String
}

"input type for updating data in table \"crew\""
input crew_set_input {
    driver_name: String
    id: uuid
    is_assigned_automatically: Boolean
    is_assigned_while_in_breaks: Boolean
    name: String
    phone_number: String
    status: crew_status_enum
    to_call_after: String
}

"Boolean expression to filter rows from the table \"crew_status\". All fields are combined with a logical 'AND'."
input crew_status_bool_exp {
    _and: [crew_status_bool_exp!]
    _not: crew_status_bool_exp
    _or: [crew_status_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"crew_status_enum\". All fields are combined with logical 'AND'."
input crew_status_enum_comparison_exp {
    _eq: crew_status_enum
    _in: [crew_status_enum!]
    _is_null: Boolean
    _neq: crew_status_enum
    _nin: [crew_status_enum!]
}

"input type for inserting data into table \"crew_status\""
input crew_status_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"crew_status\""
input crew_status_on_conflict {
    constraint: crew_status_constraint!
    update_columns: [crew_status_update_column!]! = []
    where: crew_status_bool_exp
}

"Ordering options when selecting data from \"crew_status\"."
input crew_status_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: crew_status"
input crew_status_pk_columns_input {
    value: String!
}

"input type for updating data in table \"crew_status\""
input crew_status_set_input {
    comment: String
    value: String
}

"order by aggregate values of table \"crew_zone\""
input crew_zone_aggregate_order_by {
    count: order_by
    max: crew_zone_max_order_by
    min: crew_zone_min_order_by
}

"input type for inserting array relation for remote table \"crew_zone\""
input crew_zone_arr_rel_insert_input {
    data: [crew_zone_insert_input!]!
    "upsert condition"
    on_conflict: crew_zone_on_conflict
}

"Boolean expression to filter rows from the table \"crew_zone\". All fields are combined with a logical 'AND'."
input crew_zone_bool_exp {
    _and: [crew_zone_bool_exp!]
    _not: crew_zone_bool_exp
    _or: [crew_zone_bool_exp!]
    crew: crew_bool_exp
    crew_id: uuid_comparison_exp
    id: uuid_comparison_exp
    name: String_comparison_exp
    nodes: json_comparison_exp
}

"input type for inserting data into table \"crew_zone\""
input crew_zone_insert_input {
    crew: crew_obj_rel_insert_input
    crew_id: uuid
    id: uuid
    name: String
    nodes: json
}

"order by max() on columns of table \"crew_zone\""
input crew_zone_max_order_by {
    crew_id: order_by
    id: order_by
    name: order_by
}

"order by min() on columns of table \"crew_zone\""
input crew_zone_min_order_by {
    crew_id: order_by
    id: order_by
    name: order_by
}

"on_conflict condition type for table \"crew_zone\""
input crew_zone_on_conflict {
    constraint: crew_zone_constraint!
    update_columns: [crew_zone_update_column!]! = []
    where: crew_zone_bool_exp
}

"Ordering options when selecting data from \"crew_zone\"."
input crew_zone_order_by {
    crew: crew_order_by
    crew_id: order_by
    id: order_by
    name: order_by
    nodes: order_by
}

"primary key columns input for table: crew_zone"
input crew_zone_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"crew_zone\""
input crew_zone_set_input {
    crew_id: uuid
    id: uuid
    name: String
    nodes: json
}

"Boolean expression to compare columns of type \"datetime2\". All fields are combined with logical 'AND'."
input datetime2_MSSQL_comparison_exp {
    _eq: datetime2
    _gt: datetime2
    _gte: datetime2
    _in: [datetime2!]
    _is_null: Boolean
    _lt: datetime2
    _lte: datetime2
    _neq: datetime2
    _nin: [datetime2!]
}

"Boolean expression to compare columns of type \"datetime\". All fields are combined with logical 'AND'."
input datetime_MSSQL_comparison_exp {
    _eq: datetime
    _gt: datetime
    _gte: datetime
    _in: [datetime!]
    _is_null: Boolean
    _lt: datetime
    _lte: datetime
    _neq: datetime
    _nin: [datetime!]
}

"Boolean expression to filter rows from the table \"event_status\". All fields are combined with a logical 'AND'."
input event_status_bool_exp {
    _and: [event_status_bool_exp!]
    _not: event_status_bool_exp
    _or: [event_status_bool_exp!]
    description: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"event_status_enum\". All fields are combined with logical 'AND'."
input event_status_enum_comparison_exp {
    _eq: event_status_enum
    _in: [event_status_enum!]
    _is_null: Boolean
    _neq: event_status_enum
    _nin: [event_status_enum!]
}

"input type for inserting data into table \"event_status\""
input event_status_insert_input {
    description: String
    value: String
}

"on_conflict condition type for table \"event_status\""
input event_status_on_conflict {
    constraint: event_status_constraint!
    update_columns: [event_status_update_column!]! = []
    where: event_status_bool_exp
}

"Ordering options when selecting data from \"event_status\"."
input event_status_order_by {
    description: order_by
    value: order_by
}

"primary key columns input for table: event_status"
input event_status_pk_columns_input {
    value: String!
}

"input type for updating data in table \"event_status\""
input event_status_set_input {
    description: String
    value: String
}

"Boolean expression to filter rows from the table \"events\". All fields are combined with a logical 'AND'."
input events_bool_exp {
    _and: [events_bool_exp!]
    _not: events_bool_exp
    _or: [events_bool_exp!]
    created_at: timestamptz_comparison_exp
    crew_id: uuid_comparison_exp
    description: String_comparison_exp
    id: uuid_comparison_exp
    name: String_comparison_exp
    object_id: uuid_comparison_exp
    provider_id: Int_comparison_exp
    provider_name: provider_enum_comparison_exp
    status: event_status_enum_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for incrementing numeric columns in table \"events\""
input events_inc_input {
    provider_id: Int
}

"input type for inserting data into table \"events\""
input events_insert_input {
    created_at: timestamptz
    crew_id: uuid
    description: String
    id: uuid
    name: String
    object_id: uuid
    provider_id: Int
    provider_name: provider_enum
    status: event_status_enum
    updated_at: timestamptz
}

"on_conflict condition type for table \"events\""
input events_on_conflict {
    constraint: events_constraint!
    update_columns: [events_update_column!]! = []
    where: events_bool_exp
}

"Ordering options when selecting data from \"events\"."
input events_order_by {
    created_at: order_by
    crew_id: order_by
    description: order_by
    id: order_by
    name: order_by
    object_id: order_by
    provider_id: order_by
    provider_name: order_by
    status: order_by
    updated_at: order_by
}

"primary key columns input for table: events"
input events_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"events\""
input events_set_input {
    created_at: timestamptz
    crew_id: uuid
    description: String
    id: uuid
    name: String
    object_id: uuid
    provider_id: Int
    provider_name: provider_enum
    status: event_status_enum
    updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"eventsdescription\". All fields are combined with a logical 'AND'."
input eventsdescription_bool_exp {
    Id: Int_MSSQL_comparison_exp
    SMSid: Int_MSSQL_comparison_exp
    SMSsender: Int_MSSQL_comparison_exp
    SendMail: String_MSSQL_comparison_exp
    SendSMS: String_MSSQL_comparison_exp
    SendSMStoPerson: String_MSSQL_comparison_exp
    SendViaTCP: String_MSSQL_comparison_exp
    _and: [eventsdescription_bool_exp!]
    _not: eventsdescription_bool_exp
    _or: [eventsdescription_bool_exp!]
    clasificator: String_MSSQL_comparison_exp
    eMailId: Int_MSSQL_comparison_exp
    exampleid: Int_MSSQL_comparison_exp
    expireAfter: datetime_MSSQL_comparison_exp
    forward: String_MSSQL_comparison_exp
    forwardedobjectid: Int_MSSQL_comparison_exp
    isRestoreEvent: Boolean_MSSQL_comparison_exp
    limit_sms: String_MSSQL_comparison_exp
    name: String_MSSQL_comparison_exp
    objectnr: Int_MSSQL_comparison_exp
    reaction: Int_MSSQL_comparison_exp
    relationID: Int_MSSQL_comparison_exp
    seekRestore: String_MSSQL_comparison_exp
    sms_limit_time: Int_MSSQL_comparison_exp
    sound: String_MSSQL_comparison_exp
    useinterval: String_MSSQL_comparison_exp
    value: String_MSSQL_comparison_exp
    valuefrom: String_MSSQL_comparison_exp
    valueto: String_MSSQL_comparison_exp
    window: String_MSSQL_comparison_exp
    zonenr: String_MSSQL_comparison_exp
}

"upsert condition type for table \"eventsdescription\""
input eventsdescription_if_matched {
    match_columns: [eventsdescription_insert_match_column!]! = []
    update_columns: [eventsdescription_update_column!]! = []
    where: eventsdescription_bool_exp
}

"input type for incrementing numeric columns in table \"eventsdescription\""
input eventsdescription_inc_input {
    SMSid: Int
    SMSsender: Int
    eMailId: Int
    exampleid: Int
    forwardedobjectid: Int
    objectnr: Int
    reaction: Int
    relationID: Int
    sms_limit_time: Int
}

"input type for inserting data into table \"eventsdescription\""
input eventsdescription_insert_input {
    SMSid: Int
    SMSsender: Int
    SendMail: String
    SendSMS: String
    SendSMStoPerson: String
    SendViaTCP: String
    clasificator: String
    eMailId: Int
    exampleid: Int
    expireAfter: datetime
    forward: String
    forwardedobjectid: Int
    isRestoreEvent: Boolean
    limit_sms: String
    name: String
    objectnr: Int
    reaction: Int
    relationID: Int
    seekRestore: String
    sms_limit_time: Int
    sound: String
    useinterval: String
    value: String
    valuefrom: String
    valueto: String
    window: String
    zonenr: String
}

"Ordering options when selecting data from \"eventsdescription\"."
input eventsdescription_order_by {
    Id: order_by
    SMSid: order_by
    SMSsender: order_by
    SendMail: order_by
    SendSMS: order_by
    SendSMStoPerson: order_by
    SendViaTCP: order_by
    clasificator: order_by
    eMailId: order_by
    exampleid: order_by
    expireAfter: order_by
    forward: order_by
    forwardedobjectid: order_by
    isRestoreEvent: order_by
    limit_sms: order_by
    name: order_by
    objectnr: order_by
    reaction: order_by
    relationID: order_by
    seekRestore: order_by
    sms_limit_time: order_by
    sound: order_by
    useinterval: order_by
    value: order_by
    valuefrom: order_by
    valueto: order_by
    window: order_by
    zonenr: order_by
}

"primary key columns input for table: eventsdescription"
input eventsdescription_pk_columns_input {
    Id: Int!
}

"input type for updating data in table \"eventsdescription\""
input eventsdescription_set_input {
    SMSid: Int
    SMSsender: Int
    SendMail: String
    SendSMS: String
    SendSMStoPerson: String
    SendViaTCP: String
    clasificator: String
    eMailId: Int
    exampleid: Int
    expireAfter: datetime
    forward: String
    forwardedobjectid: Int
    isRestoreEvent: Boolean
    limit_sms: String
    name: String
    objectnr: Int
    reaction: Int
    relationID: Int
    seekRestore: String
    sms_limit_time: Int
    sound: String
    useinterval: String
    value: String
    valuefrom: String
    valueto: String
    window: String
    zonenr: String
}

"append existing jsonb value of filtered columns with new jsonb value"
input filters_append_input {
    dashboardList: jsonb
}

"Boolean expression to filter rows from the table \"filters\". All fields are combined with a logical 'AND'."
input filters_bool_exp {
    Id: uuid_comparison_exp
    _and: [filters_bool_exp!]
    _not: filters_bool_exp
    _or: [filters_bool_exp!]
    crew: String_comparison_exp
    dashboardList: jsonb_comparison_exp
    date: String_comparison_exp
    driver: String_comparison_exp
    filterName: String_comparison_exp
    filterShortName: String_comparison_exp
    group: String_comparison_exp
    id: String_comparison_exp
    inTime: String_comparison_exp
    object: String_comparison_exp
    objectAddress: String_comparison_exp
    operator: String_comparison_exp
    reason: String_comparison_exp
    savedToFavorite: Boolean_comparison_exp
    savedToMenu: Boolean_comparison_exp
    status: String_comparison_exp
    type: String_comparison_exp
    userId: String_comparison_exp
}

"delete the field or element with specified path (for JSON arrays, negative integers count from the end)"
input filters_delete_at_path_input {
    dashboardList: [String!]
}

"delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array"
input filters_delete_elem_input {
    dashboardList: Int
}

"delete key/value pair or string element. key/value pairs are matched based on their key value"
input filters_delete_key_input {
    dashboardList: String
}

"input type for inserting data into table \"filters\""
input filters_insert_input {
    Id: uuid
    crew: String
    dashboardList: jsonb
    date: String
    driver: String
    filterName: String
    filterShortName: String
    group: String
    id: String
    inTime: String
    object: String
    objectAddress: String
    operator: String
    reason: String
    savedToFavorite: Boolean
    savedToMenu: Boolean
    status: String
    type: String
    userId: String
}

"on_conflict condition type for table \"filters\""
input filters_on_conflict {
    constraint: filters_constraint!
    update_columns: [filters_update_column!]! = []
    where: filters_bool_exp
}

"Ordering options when selecting data from \"filters\"."
input filters_order_by {
    Id: order_by
    crew: order_by
    dashboardList: order_by
    date: order_by
    driver: order_by
    filterName: order_by
    filterShortName: order_by
    group: order_by
    id: order_by
    inTime: order_by
    object: order_by
    objectAddress: order_by
    operator: order_by
    reason: order_by
    savedToFavorite: order_by
    savedToMenu: order_by
    status: order_by
    type: order_by
    userId: order_by
}

"primary key columns input for table: filters"
input filters_pk_columns_input {
    Id: uuid!
}

"prepend existing jsonb value of filtered columns with new jsonb value"
input filters_prepend_input {
    dashboardList: jsonb
}

"input type for updating data in table \"filters\""
input filters_set_input {
    Id: uuid
    crew: String
    dashboardList: jsonb
    date: String
    driver: String
    filterName: String
    filterShortName: String
    group: String
    id: String
    inTime: String
    object: String
    objectAddress: String
    operator: String
    reason: String
    savedToFavorite: Boolean
    savedToMenu: Boolean
    status: String
    type: String
    userId: String
}

"Boolean expression to compare columns of type \"interval\". All fields are combined with logical 'AND'."
input interval_comparison_exp {
    _eq: interval
    _gt: interval
    _gte: interval
    _in: [interval!]
    _is_null: Boolean
    _lt: interval
    _lte: interval
    _neq: interval
    _nin: [interval!]
}

"Boolean expression to compare columns of type \"json\". All fields are combined with logical 'AND'."
input json_comparison_exp {
    _eq: json
    _gt: json
    _gte: json
    _in: [json!]
    _is_null: Boolean
    _lt: json
    _lte: json
    _neq: json
    _nin: [json!]
}

input jsonb_cast_exp {
    String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
    _cast: jsonb_cast_exp
    "is the column contained in the given json value"
    _contained_in: jsonb
    "does the column contain the given json value at the top level"
    _contains: jsonb
    _eq: jsonb
    _gt: jsonb
    _gte: jsonb
    "does the string exist as a top-level key in the column"
    _has_key: String
    "do all of these strings exist as top-level keys in the column"
    _has_keys_all: [String!]
    "do any of these strings exist as top-level keys in the column"
    _has_keys_any: [String!]
    _in: [jsonb!]
    _is_null: Boolean
    _lt: jsonb
    _lte: jsonb
    _neq: jsonb
    _nin: [jsonb!]
}

"Boolean expression to filter rows from the table \"events\". All fields are combined with a logical 'AND'."
input monas_events_bool_exp {
    ObjectName: String_MSSQL_comparison_exp
    Remind: String_MSSQL_comparison_exp
    RemindAtTime: datetime_MSSQL_comparison_exp
    RemindFromTime: datetime_MSSQL_comparison_exp
    RemindInHours: Int_MSSQL_comparison_exp
    RemindInMinutes: Int_MSSQL_comparison_exp
    Reminder: String_MSSQL_comparison_exp
    _and: [monas_events_bool_exp!]
    _not: monas_events_bool_exp
    _or: [monas_events_bool_exp!]
    action: Int_MSSQL_comparison_exp
    addedtoarchivetime: datetime_MSSQL_comparison_exp
    clasificator: String_MSSQL_comparison_exp
    closedby: String_MSSQL_comparison_exp
    eventcode: String_MSSQL_comparison_exp
    eventdescid: Int_MSSQL_comparison_exp
    eventname: String_MSSQL_comparison_exp
    eventsource: Int_MSSQL_comparison_exp
    groupnr: Int_MSSQL_comparison_exp
    id: Int_MSSQL_comparison_exp
    linename: String_MSSQL_comparison_exp
    linenr: Int_MSSQL_comparison_exp
    lockedby: Int_MSSQL_comparison_exp
    objectdbid: Int_MSSQL_comparison_exp
    objectnr: Int_MSSQL_comparison_exp
    playsound: String_MSSQL_comparison_exp
    priority: Int_MSSQL_comparison_exp
    reactedby: String_MSSQL_comparison_exp
    reactedtime: datetime_MSSQL_comparison_exp
    reactionid: Int_MSSQL_comparison_exp
    reactiontype: Int_MSSQL_comparison_exp
    receivedlevel: Int_MSSQL_comparison_exp
    receivedtime: datetime_MSSQL_comparison_exp
    receivername: String_MSSQL_comparison_exp
    receivernr: Int_MSSQL_comparison_exp
    relationid: Int_MSSQL_comparison_exp
    repeated: String_MSSQL_comparison_exp
    retranslator: Int_MSSQL_comparison_exp
    retranslatorlevel: Int_MSSQL_comparison_exp
    selectable: Int_MSSQL_comparison_exp
    status: Int_MSSQL_comparison_exp
    unifier_id: Int_MSSQL_comparison_exp
    wasDriverAcquired: Boolean_MSSQL_comparison_exp
    zonenumber: String_MSSQL_comparison_exp
}

"upsert condition type for table \"events\""
input monas_events_if_matched {
    match_columns: [monas_events_insert_match_column!]! = []
    update_columns: [monas_events_update_column!]! = []
    where: monas_events_bool_exp
}

"input type for incrementing numeric columns in table \"events\""
input monas_events_inc_input {
    RemindInHours: Int
    RemindInMinutes: Int
    action: Int
    eventdescid: Int
    eventsource: Int
    groupnr: Int
    linenr: Int
    lockedby: Int
    objectdbid: Int
    objectnr: Int
    priority: Int
    reactionid: Int
    reactiontype: Int
    receivedlevel: Int
    receivernr: Int
    relationid: Int
    retranslator: Int
    retranslatorlevel: Int
    selectable: Int
    status: Int
    unifier_id: Int
}

"input type for inserting data into table \"events\""
input monas_events_insert_input {
    ObjectName: String
    Remind: String
    RemindAtTime: datetime
    RemindFromTime: datetime
    RemindInHours: Int
    RemindInMinutes: Int
    Reminder: String
    action: Int
    addedtoarchivetime: datetime
    clasificator: String
    closedby: String
    eventcode: String
    eventdescid: Int
    eventname: String
    eventsource: Int
    groupnr: Int
    linename: String
    linenr: Int
    lockedby: Int
    objectdbid: Int
    objectnr: Int
    playsound: String
    priority: Int
    reactedby: String
    reactedtime: datetime
    reactionid: Int
    reactiontype: Int
    receivedlevel: Int
    receivedtime: datetime
    receivername: String
    receivernr: Int
    relationid: Int
    repeated: String
    retranslator: Int
    retranslatorlevel: Int
    selectable: Int
    status: Int
    unifier_id: Int
    wasDriverAcquired: Boolean
    zonenumber: String
}

"Ordering options when selecting data from \"events\"."
input monas_events_order_by {
    ObjectName: order_by
    Remind: order_by
    RemindAtTime: order_by
    RemindFromTime: order_by
    RemindInHours: order_by
    RemindInMinutes: order_by
    Reminder: order_by
    action: order_by
    addedtoarchivetime: order_by
    clasificator: order_by
    closedby: order_by
    eventcode: order_by
    eventdescid: order_by
    eventname: order_by
    eventsource: order_by
    groupnr: order_by
    id: order_by
    linename: order_by
    linenr: order_by
    lockedby: order_by
    objectdbid: order_by
    objectnr: order_by
    playsound: order_by
    priority: order_by
    reactedby: order_by
    reactedtime: order_by
    reactionid: order_by
    reactiontype: order_by
    receivedlevel: order_by
    receivedtime: order_by
    receivername: order_by
    receivernr: order_by
    relationid: order_by
    repeated: order_by
    retranslator: order_by
    retranslatorlevel: order_by
    selectable: order_by
    status: order_by
    unifier_id: order_by
    wasDriverAcquired: order_by
    zonenumber: order_by
}

"primary key columns input for table: monas_events"
input monas_events_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"events\""
input monas_events_set_input {
    ObjectName: String
    Remind: String
    RemindAtTime: datetime
    RemindFromTime: datetime
    RemindInHours: Int
    RemindInMinutes: Int
    Reminder: String
    action: Int
    addedtoarchivetime: datetime
    clasificator: String
    closedby: String
    eventcode: String
    eventdescid: Int
    eventname: String
    eventsource: Int
    groupnr: Int
    linename: String
    linenr: Int
    lockedby: Int
    objectdbid: Int
    objectnr: Int
    playsound: String
    priority: Int
    reactedby: String
    reactedtime: datetime
    reactionid: Int
    reactiontype: Int
    receivedlevel: Int
    receivedtime: datetime
    receivername: String
    receivernr: Int
    relationid: Int
    repeated: String
    retranslator: Int
    retranslatorlevel: Int
    selectable: Int
    status: Int
    unifier_id: Int
    wasDriverAcquired: Boolean
    zonenumber: String
}

"Boolean expression to filter rows from the table \"objects\". All fields are combined with a logical 'AND'."
input monas_objects_bool_exp {
    AcLossDetected: datetime_MSSQL_comparison_exp
    DcLossDetected: datetime_MSSQL_comparison_exp
    Id: Int_MSSQL_comparison_exp
    Locked: Int_MSSQL_comparison_exp
    MainSubDisabled: String_MSSQL_comparison_exp
    MainSubDriverReactionTimes: String_MSSQL_comparison_exp
    MainSubEvents: String_MSSQL_comparison_exp
    MainSubGenerated: String_MSSQL_comparison_exp
    MainSubId: Int_MSSQL_comparison_exp
    MainSubInfo: String_MSSQL_comparison_exp
    MainSubMoreNotes: String_MSSQL_comparison_exp
    MainSubOpenClose: String_MSSQL_comparison_exp
    MainSubPersons: String_MSSQL_comparison_exp
    MainSubSchemes: String_MSSQL_comparison_exp
    MainSubTest: String_MSSQL_comparison_exp
    MainSubZones: String_MSSQL_comparison_exp
    NotesText: varbinary_MSSQL_comparison_exp
    OpenCloseSeekState: Int_MSSQL_comparison_exp
    TS: timestamp_MSSQL_comparison_exp
    _and: [monas_objects_bool_exp!]
    _not: monas_objects_bool_exp
    _or: [monas_objects_bool_exp!]
    address: String_MSSQL_comparison_exp
    assignedeventexampleid: Int_MSSQL_comparison_exp
    assignedgroupableeventexampleid: Int_MSSQL_comparison_exp
    celebrationsclosehour: Int_MSSQL_comparison_exp
    celebrationsclosemin: Int_MSSQL_comparison_exp
    celebrationsopenhour: Int_MSSQL_comparison_exp
    celebrationsopenmin: Int_MSSQL_comparison_exp
    city: Int_MSSQL_comparison_exp
    closedeviation: Int_MSSQL_comparison_exp
    closedeviationneg: Int_MSSQL_comparison_exp
    closehourdefault: Int_MSSQL_comparison_exp
    closemindefault: Int_MSSQL_comparison_exp
    contract: String_MSSQL_comparison_exp
    contract2: String_MSSQL_comparison_exp
    destination: Int_MSSQL_comparison_exp
    dynamic: Boolean_MSSQL_comparison_exp
    firsttest: time_MSSQL_comparison_exp
    freeEvents: Int_MSSQL_comparison_exp
    fridayclosehour: Int_MSSQL_comparison_exp
    fridayclosemin: Int_MSSQL_comparison_exp
    fridayopenhour: Int_MSSQL_comparison_exp
    fridayopenmin: Int_MSSQL_comparison_exp
    generatedeventsexample: Int_MSSQL_comparison_exp
    grg_info: String_MSSQL_comparison_exp
    groupid: Int_MSSQL_comparison_exp
    installed: String_MSSQL_comparison_exp
    installer: Int_MSSQL_comparison_exp
    installerCompany: Int_MSSQL_comparison_exp
    intlinenr: Int_MSSQL_comparison_exp
    intreceivernr: Int_MSSQL_comparison_exp
    lastPersonToOpenClose: Int_MSSQL_comparison_exp
    lasttesttime: datetime2_MSSQL_comparison_exp
    latitude: Float_MSSQL_comparison_exp
    linenr: String_MSSQL_comparison_exp
    longitude: Float_MSSQL_comparison_exp
    mainsubgroup: String_MSSQL_comparison_exp
    mondayclosehour: Int_MSSQL_comparison_exp
    mondayclosemin: Int_MSSQL_comparison_exp
    mondayopenhour: Int_MSSQL_comparison_exp
    mondayopenmin: Int_MSSQL_comparison_exp
    mustopen: String_MSSQL_comparison_exp
    name: String_MSSQL_comparison_exp
    notes: String_MSSQL_comparison_exp
    obdindx: String_MSSQL_comparison_exp
    objectid: Int_MSSQL_comparison_exp
    objectstate: Int_MSSQL_comparison_exp
    objectstatus: Int_MSSQL_comparison_exp
    opendeviation: Int_MSSQL_comparison_exp
    opendeviationneg: Int_MSSQL_comparison_exp
    openhourdefault: Int_MSSQL_comparison_exp
    openmindefault: Int_MSSQL_comparison_exp
    otherevents: String_MSSQL_comparison_exp
    phone: String_MSSQL_comparison_exp
    reacttoeachevent: Int_MSSQL_comparison_exp
    receivernr: String_MSSQL_comparison_exp
    region: Int_MSSQL_comparison_exp
    relationId: Int_MSSQL_comparison_exp
    saturdayclosehour: Int_MSSQL_comparison_exp
    saturdayclosemin: Int_MSSQL_comparison_exp
    saturdayopenhour: Int_MSSQL_comparison_exp
    saturdayopenmin: Int_MSSQL_comparison_exp
    seekcelebrationsclose: String_MSSQL_comparison_exp
    seekcelebrationsopen: String_MSSQL_comparison_exp
    seekcloseworktime: String_MSSQL_comparison_exp
    seekfridayclose: String_MSSQL_comparison_exp
    seekfridayopen: String_MSSQL_comparison_exp
    seekmondayclose: String_MSSQL_comparison_exp
    seekmondayopen: String_MSSQL_comparison_exp
    seekopenworktime: String_MSSQL_comparison_exp
    seeksaturdayclose: String_MSSQL_comparison_exp
    seeksaturdayopen: String_MSSQL_comparison_exp
    seeksundayclose: String_MSSQL_comparison_exp
    seeksundayopen: String_MSSQL_comparison_exp
    seekthursdayclose: String_MSSQL_comparison_exp
    seekthursdayopen: String_MSSQL_comparison_exp
    seektuesdayclose: String_MSSQL_comparison_exp
    seektuesdayopen: String_MSSQL_comparison_exp
    seekwednesdayclose: String_MSSQL_comparison_exp
    seekwednesdayopen: String_MSSQL_comparison_exp
    specialcelebrations: String_MSSQL_comparison_exp
    specialfriday: String_MSSQL_comparison_exp
    specialmonday: String_MSSQL_comparison_exp
    specialsaturday: String_MSSQL_comparison_exp
    specialsunday: String_MSSQL_comparison_exp
    specialthursday: String_MSSQL_comparison_exp
    specialtuesday: String_MSSQL_comparison_exp
    specialwednesday: String_MSSQL_comparison_exp
    street: Int_MSSQL_comparison_exp
    subdivision: Int_MSSQL_comparison_exp
    subgroup: Int_MSSQL_comparison_exp
    sundayclosehour: Int_MSSQL_comparison_exp
    sundayclosemin: Int_MSSQL_comparison_exp
    sundayopenhour: Int_MSSQL_comparison_exp
    sundayopenmin: Int_MSSQL_comparison_exp
    synchronize: Boolean_MSSQL_comparison_exp
    testtype: Int_MSSQL_comparison_exp
    thursdayclosehour: Int_MSSQL_comparison_exp
    thursdayclosemin: Int_MSSQL_comparison_exp
    thursdayopenhour: Int_MSSQL_comparison_exp
    thursdayopenmin: Int_MSSQL_comparison_exp
    timebetweentestdays: Int_MSSQL_comparison_exp
    timebetweentesttime: time_MSSQL_comparison_exp
    timesperday: Int_MSSQL_comparison_exp
    timestamp: datetime_MSSQL_comparison_exp
    tolerance: Int_MSSQL_comparison_exp
    transinstdate: String_MSSQL_comparison_exp
    tuesdayclosehour: Int_MSSQL_comparison_exp
    tuesdayclosemin: Int_MSSQL_comparison_exp
    tuesdayopenhour: Int_MSSQL_comparison_exp
    tuesdayopenmin: Int_MSSQL_comparison_exp
    unifier_id: Int_MSSQL_comparison_exp
    uniqueID: uniqueidentifier_MSSQL_comparison_exp
    useeventexample: String_MSSQL_comparison_exp
    usegroupableeventsexample: String_MSSQL_comparison_exp
    wednesdayclosehour: Int_MSSQL_comparison_exp
    wednesdayclosemin: Int_MSSQL_comparison_exp
    wednesdayopenhour: Int_MSSQL_comparison_exp
    wednesdayopenmin: Int_MSSQL_comparison_exp
}

"upsert condition type for table \"objects\""
input monas_objects_if_matched {
    match_columns: [monas_objects_insert_match_column!]! = []
    update_columns: [monas_objects_update_column!]! = []
    where: monas_objects_bool_exp
}

"input type for incrementing numeric columns in table \"objects\""
input monas_objects_inc_input {
    Locked: Int
    MainSubId: Int
    OpenCloseSeekState: Int
    assignedeventexampleid: Int
    assignedgroupableeventexampleid: Int
    celebrationsclosehour: Int
    celebrationsclosemin: Int
    celebrationsopenhour: Int
    celebrationsopenmin: Int
    city: Int
    closedeviation: Int
    closedeviationneg: Int
    closehourdefault: Int
    closemindefault: Int
    destination: Int
    freeEvents: Int
    fridayclosehour: Int
    fridayclosemin: Int
    fridayopenhour: Int
    fridayopenmin: Int
    generatedeventsexample: Int
    groupid: Int
    installer: Int
    installerCompany: Int
    intlinenr: Int
    intreceivernr: Int
    lastPersonToOpenClose: Int
    latitude: Float
    longitude: Float
    mondayclosehour: Int
    mondayclosemin: Int
    mondayopenhour: Int
    mondayopenmin: Int
    objectid: Int
    objectstate: Int
    objectstatus: Int
    opendeviation: Int
    opendeviationneg: Int
    openhourdefault: Int
    openmindefault: Int
    reacttoeachevent: Int
    region: Int
    relationId: Int
    saturdayclosehour: Int
    saturdayclosemin: Int
    saturdayopenhour: Int
    saturdayopenmin: Int
    street: Int
    subdivision: Int
    subgroup: Int
    sundayclosehour: Int
    sundayclosemin: Int
    sundayopenhour: Int
    sundayopenmin: Int
    testtype: Int
    thursdayclosehour: Int
    thursdayclosemin: Int
    thursdayopenhour: Int
    thursdayopenmin: Int
    timebetweentestdays: Int
    timesperday: Int
    tolerance: Int
    tuesdayclosehour: Int
    tuesdayclosemin: Int
    tuesdayopenhour: Int
    tuesdayopenmin: Int
    unifier_id: Int
    wednesdayclosehour: Int
    wednesdayclosemin: Int
    wednesdayopenhour: Int
    wednesdayopenmin: Int
}

"input type for inserting data into table \"objects\""
input monas_objects_insert_input {
    AcLossDetected: datetime
    DcLossDetected: datetime
    Locked: Int
    MainSubDisabled: String
    MainSubDriverReactionTimes: String
    MainSubEvents: String
    MainSubGenerated: String
    MainSubId: Int
    MainSubInfo: String
    MainSubMoreNotes: String
    MainSubOpenClose: String
    MainSubPersons: String
    MainSubSchemes: String
    MainSubTest: String
    MainSubZones: String
    NotesText: varbinary
    OpenCloseSeekState: Int
    TS: timestamp
    address: String
    assignedeventexampleid: Int
    assignedgroupableeventexampleid: Int
    celebrationsclosehour: Int
    celebrationsclosemin: Int
    celebrationsopenhour: Int
    celebrationsopenmin: Int
    city: Int
    closedeviation: Int
    closedeviationneg: Int
    closehourdefault: Int
    closemindefault: Int
    contract: String
    contract2: String
    destination: Int
    dynamic: Boolean
    firsttest: time
    freeEvents: Int
    fridayclosehour: Int
    fridayclosemin: Int
    fridayopenhour: Int
    fridayopenmin: Int
    generatedeventsexample: Int
    grg_info: String
    groupid: Int
    installed: String
    installer: Int
    installerCompany: Int
    intlinenr: Int
    intreceivernr: Int
    lastPersonToOpenClose: Int
    lasttesttime: datetime2
    latitude: Float
    linenr: String
    longitude: Float
    mainsubgroup: String
    mondayclosehour: Int
    mondayclosemin: Int
    mondayopenhour: Int
    mondayopenmin: Int
    mustopen: String
    name: String
    notes: String
    obdindx: String
    objectid: Int
    objectstate: Int
    objectstatus: Int
    opendeviation: Int
    opendeviationneg: Int
    openhourdefault: Int
    openmindefault: Int
    otherevents: String
    phone: String
    reacttoeachevent: Int
    receivernr: String
    region: Int
    relationId: Int
    saturdayclosehour: Int
    saturdayclosemin: Int
    saturdayopenhour: Int
    saturdayopenmin: Int
    seekcelebrationsclose: String
    seekcelebrationsopen: String
    seekcloseworktime: String
    seekfridayclose: String
    seekfridayopen: String
    seekmondayclose: String
    seekmondayopen: String
    seekopenworktime: String
    seeksaturdayclose: String
    seeksaturdayopen: String
    seeksundayclose: String
    seeksundayopen: String
    seekthursdayclose: String
    seekthursdayopen: String
    seektuesdayclose: String
    seektuesdayopen: String
    seekwednesdayclose: String
    seekwednesdayopen: String
    specialcelebrations: String
    specialfriday: String
    specialmonday: String
    specialsaturday: String
    specialsunday: String
    specialthursday: String
    specialtuesday: String
    specialwednesday: String
    street: Int
    subdivision: Int
    subgroup: Int
    sundayclosehour: Int
    sundayclosemin: Int
    sundayopenhour: Int
    sundayopenmin: Int
    synchronize: Boolean
    testtype: Int
    thursdayclosehour: Int
    thursdayclosemin: Int
    thursdayopenhour: Int
    thursdayopenmin: Int
    timebetweentestdays: Int
    timebetweentesttime: time
    timesperday: Int
    timestamp: datetime
    tolerance: Int
    transinstdate: String
    tuesdayclosehour: Int
    tuesdayclosemin: Int
    tuesdayopenhour: Int
    tuesdayopenmin: Int
    unifier_id: Int
    uniqueID: uniqueidentifier
    useeventexample: String
    usegroupableeventsexample: String
    wednesdayclosehour: Int
    wednesdayclosemin: Int
    wednesdayopenhour: Int
    wednesdayopenmin: Int
}

"Ordering options when selecting data from \"objects\"."
input monas_objects_order_by {
    AcLossDetected: order_by
    DcLossDetected: order_by
    Id: order_by
    Locked: order_by
    MainSubDisabled: order_by
    MainSubDriverReactionTimes: order_by
    MainSubEvents: order_by
    MainSubGenerated: order_by
    MainSubId: order_by
    MainSubInfo: order_by
    MainSubMoreNotes: order_by
    MainSubOpenClose: order_by
    MainSubPersons: order_by
    MainSubSchemes: order_by
    MainSubTest: order_by
    MainSubZones: order_by
    NotesText: order_by
    OpenCloseSeekState: order_by
    TS: order_by
    address: order_by
    assignedeventexampleid: order_by
    assignedgroupableeventexampleid: order_by
    celebrationsclosehour: order_by
    celebrationsclosemin: order_by
    celebrationsopenhour: order_by
    celebrationsopenmin: order_by
    city: order_by
    closedeviation: order_by
    closedeviationneg: order_by
    closehourdefault: order_by
    closemindefault: order_by
    contract: order_by
    contract2: order_by
    destination: order_by
    dynamic: order_by
    firsttest: order_by
    freeEvents: order_by
    fridayclosehour: order_by
    fridayclosemin: order_by
    fridayopenhour: order_by
    fridayopenmin: order_by
    generatedeventsexample: order_by
    grg_info: order_by
    groupid: order_by
    installed: order_by
    installer: order_by
    installerCompany: order_by
    intlinenr: order_by
    intreceivernr: order_by
    lastPersonToOpenClose: order_by
    lasttesttime: order_by
    latitude: order_by
    linenr: order_by
    longitude: order_by
    mainsubgroup: order_by
    mondayclosehour: order_by
    mondayclosemin: order_by
    mondayopenhour: order_by
    mondayopenmin: order_by
    mustopen: order_by
    name: order_by
    notes: order_by
    obdindx: order_by
    objectid: order_by
    objectstate: order_by
    objectstatus: order_by
    opendeviation: order_by
    opendeviationneg: order_by
    openhourdefault: order_by
    openmindefault: order_by
    otherevents: order_by
    phone: order_by
    reacttoeachevent: order_by
    receivernr: order_by
    region: order_by
    relationId: order_by
    saturdayclosehour: order_by
    saturdayclosemin: order_by
    saturdayopenhour: order_by
    saturdayopenmin: order_by
    seekcelebrationsclose: order_by
    seekcelebrationsopen: order_by
    seekcloseworktime: order_by
    seekfridayclose: order_by
    seekfridayopen: order_by
    seekmondayclose: order_by
    seekmondayopen: order_by
    seekopenworktime: order_by
    seeksaturdayclose: order_by
    seeksaturdayopen: order_by
    seeksundayclose: order_by
    seeksundayopen: order_by
    seekthursdayclose: order_by
    seekthursdayopen: order_by
    seektuesdayclose: order_by
    seektuesdayopen: order_by
    seekwednesdayclose: order_by
    seekwednesdayopen: order_by
    specialcelebrations: order_by
    specialfriday: order_by
    specialmonday: order_by
    specialsaturday: order_by
    specialsunday: order_by
    specialthursday: order_by
    specialtuesday: order_by
    specialwednesday: order_by
    street: order_by
    subdivision: order_by
    subgroup: order_by
    sundayclosehour: order_by
    sundayclosemin: order_by
    sundayopenhour: order_by
    sundayopenmin: order_by
    synchronize: order_by
    testtype: order_by
    thursdayclosehour: order_by
    thursdayclosemin: order_by
    thursdayopenhour: order_by
    thursdayopenmin: order_by
    timebetweentestdays: order_by
    timebetweentesttime: order_by
    timesperday: order_by
    timestamp: order_by
    tolerance: order_by
    transinstdate: order_by
    tuesdayclosehour: order_by
    tuesdayclosemin: order_by
    tuesdayopenhour: order_by
    tuesdayopenmin: order_by
    unifier_id: order_by
    uniqueID: order_by
    useeventexample: order_by
    usegroupableeventsexample: order_by
    wednesdayclosehour: order_by
    wednesdayclosemin: order_by
    wednesdayopenhour: order_by
    wednesdayopenmin: order_by
}

"primary key columns input for table: monas_objects"
input monas_objects_pk_columns_input {
    Id: Int!
}

"input type for updating data in table \"objects\""
input monas_objects_set_input {
    AcLossDetected: datetime
    DcLossDetected: datetime
    Locked: Int
    MainSubDisabled: String
    MainSubDriverReactionTimes: String
    MainSubEvents: String
    MainSubGenerated: String
    MainSubId: Int
    MainSubInfo: String
    MainSubMoreNotes: String
    MainSubOpenClose: String
    MainSubPersons: String
    MainSubSchemes: String
    MainSubTest: String
    MainSubZones: String
    NotesText: varbinary
    OpenCloseSeekState: Int
    TS: timestamp
    address: String
    assignedeventexampleid: Int
    assignedgroupableeventexampleid: Int
    celebrationsclosehour: Int
    celebrationsclosemin: Int
    celebrationsopenhour: Int
    celebrationsopenmin: Int
    city: Int
    closedeviation: Int
    closedeviationneg: Int
    closehourdefault: Int
    closemindefault: Int
    contract: String
    contract2: String
    destination: Int
    dynamic: Boolean
    firsttest: time
    freeEvents: Int
    fridayclosehour: Int
    fridayclosemin: Int
    fridayopenhour: Int
    fridayopenmin: Int
    generatedeventsexample: Int
    grg_info: String
    groupid: Int
    installed: String
    installer: Int
    installerCompany: Int
    intlinenr: Int
    intreceivernr: Int
    lastPersonToOpenClose: Int
    lasttesttime: datetime2
    latitude: Float
    linenr: String
    longitude: Float
    mainsubgroup: String
    mondayclosehour: Int
    mondayclosemin: Int
    mondayopenhour: Int
    mondayopenmin: Int
    mustopen: String
    name: String
    notes: String
    obdindx: String
    objectid: Int
    objectstate: Int
    objectstatus: Int
    opendeviation: Int
    opendeviationneg: Int
    openhourdefault: Int
    openmindefault: Int
    otherevents: String
    phone: String
    reacttoeachevent: Int
    receivernr: String
    region: Int
    relationId: Int
    saturdayclosehour: Int
    saturdayclosemin: Int
    saturdayopenhour: Int
    saturdayopenmin: Int
    seekcelebrationsclose: String
    seekcelebrationsopen: String
    seekcloseworktime: String
    seekfridayclose: String
    seekfridayopen: String
    seekmondayclose: String
    seekmondayopen: String
    seekopenworktime: String
    seeksaturdayclose: String
    seeksaturdayopen: String
    seeksundayclose: String
    seeksundayopen: String
    seekthursdayclose: String
    seekthursdayopen: String
    seektuesdayclose: String
    seektuesdayopen: String
    seekwednesdayclose: String
    seekwednesdayopen: String
    specialcelebrations: String
    specialfriday: String
    specialmonday: String
    specialsaturday: String
    specialsunday: String
    specialthursday: String
    specialtuesday: String
    specialwednesday: String
    street: Int
    subdivision: Int
    subgroup: Int
    sundayclosehour: Int
    sundayclosemin: Int
    sundayopenhour: Int
    sundayopenmin: Int
    synchronize: Boolean
    testtype: Int
    thursdayclosehour: Int
    thursdayclosemin: Int
    thursdayopenhour: Int
    thursdayopenmin: Int
    timebetweentestdays: Int
    timebetweentesttime: time
    timesperday: Int
    timestamp: datetime
    tolerance: Int
    transinstdate: String
    tuesdayclosehour: Int
    tuesdayclosemin: Int
    tuesdayopenhour: Int
    tuesdayopenmin: Int
    unifier_id: Int
    uniqueID: uniqueidentifier
    useeventexample: String
    usegroupableeventsexample: String
    wednesdayclosehour: Int
    wednesdayclosemin: Int
    wednesdayopenhour: Int
    wednesdayopenmin: Int
}

"Boolean expression to filter rows from the table \"monas_related\". All fields are combined with a logical 'AND'."
input monas_related_bool_exp {
    Id: String_comparison_exp
    _and: [monas_related_bool_exp!]
    _not: monas_related_bool_exp
    _or: [monas_related_bool_exp!]
    area_no: String_comparison_exp
    assign_car: String_comparison_exp
    atm: String_comparison_exp
    contact: String_comparison_exp
    id: uuid_comparison_exp
    image: String_comparison_exp
    imagename: String_comparison_exp
    modem: String_comparison_exp
    monasid: Int_comparison_exp
    navid: Int_comparison_exp
    object_contract: String_comparison_exp
    object_key: String_comparison_exp
    send_crew: Boolean_comparison_exp
}

"input type for incrementing numeric columns in table \"monas_related\""
input monas_related_inc_input {
    monasid: Int
    navid: Int
}

"input type for inserting data into table \"monas_related\""
input monas_related_insert_input {
    Id: String
    area_no: String
    assign_car: String
    atm: String
    contact: String
    id: uuid
    image: String
    imagename: String
    modem: String
    monasid: Int
    navid: Int
    object_contract: String
    object_key: String
    send_crew: Boolean
}

"on_conflict condition type for table \"monas_related\""
input monas_related_on_conflict {
    constraint: monas_related_constraint!
    update_columns: [monas_related_update_column!]! = []
    where: monas_related_bool_exp
}

"Ordering options when selecting data from \"monas_related\"."
input monas_related_order_by {
    Id: order_by
    area_no: order_by
    assign_car: order_by
    atm: order_by
    contact: order_by
    id: order_by
    image: order_by
    imagename: order_by
    modem: order_by
    monasid: order_by
    navid: order_by
    object_contract: order_by
    object_key: order_by
    send_crew: order_by
}

"primary key columns input for table: monas_related"
input monas_related_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"monas_related\""
input monas_related_set_input {
    Id: String
    area_no: String
    assign_car: String
    atm: String
    contact: String
    id: uuid
    image: String
    imagename: String
    modem: String
    monasid: Int
    navid: Int
    object_contract: String
    object_key: String
    send_crew: Boolean
}

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _is_null: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
}

"Boolean expression to filter rows from the table \"object\". All fields are combined with a logical 'AND'."
input object_bool_exp {
    _and: [object_bool_exp!]
    _not: object_bool_exp
    _or: [object_bool_exp!]
    address: String_comparison_exp
    city: city_enum_comparison_exp
    contract_no: String_comparison_exp
    contract_object_no: String_comparison_exp
    description: String_comparison_exp
    id: uuid_comparison_exp
    images: object_image_bool_exp
    is_atm: Boolean_comparison_exp
    is_crew_autoasigned: Boolean_comparison_exp
    keys: object_key_rels_bool_exp
    latitude: numeric_comparison_exp
    longitude: numeric_comparison_exp
    modems: object_modem_bool_exp
    name: String_comparison_exp
    navision_id: Int_comparison_exp
    phone: String_comparison_exp
    provider_id: Int_comparison_exp
    provider_name: provider_enum_comparison_exp
    users: object_user_rel_bool_exp
}

"order by aggregate values of table \"object_image\""
input object_image_aggregate_order_by {
    count: order_by
    max: object_image_max_order_by
    min: object_image_min_order_by
}

"input type for inserting array relation for remote table \"object_image\""
input object_image_arr_rel_insert_input {
    data: [object_image_insert_input!]!
    "upsert condition"
    on_conflict: object_image_on_conflict
}

"Boolean expression to filter rows from the table \"object_image\". All fields are combined with a logical 'AND'."
input object_image_bool_exp {
    _and: [object_image_bool_exp!]
    _not: object_image_bool_exp
    _or: [object_image_bool_exp!]
    id: uuid_comparison_exp
    object: object_bool_exp
    object_id: uuid_comparison_exp
    src: String_comparison_exp
}

"input type for inserting data into table \"object_image\""
input object_image_insert_input {
    id: uuid
    object: object_obj_rel_insert_input
    object_id: uuid
    src: String
}

"order by max() on columns of table \"object_image\""
input object_image_max_order_by {
    id: order_by
    object_id: order_by
    src: order_by
}

"order by min() on columns of table \"object_image\""
input object_image_min_order_by {
    id: order_by
    object_id: order_by
    src: order_by
}

"on_conflict condition type for table \"object_image\""
input object_image_on_conflict {
    constraint: object_image_constraint!
    update_columns: [object_image_update_column!]! = []
    where: object_image_bool_exp
}

"Ordering options when selecting data from \"object_image\"."
input object_image_order_by {
    id: order_by
    object: object_order_by
    object_id: order_by
    src: order_by
}

"primary key columns input for table: object_image"
input object_image_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"object_image\""
input object_image_set_input {
    id: uuid
    object_id: uuid
    src: String
}

"input type for incrementing numeric columns in table \"object\""
input object_inc_input {
    latitude: numeric
    longitude: numeric
    navision_id: Int
    provider_id: Int
}

"input type for inserting data into table \"object\""
input object_insert_input {
    address: String
    city: city_enum
    contract_no: String
    contract_object_no: String
    description: String
    id: uuid
    images: object_image_arr_rel_insert_input
    is_atm: Boolean
    is_crew_autoasigned: Boolean
    keys: object_key_rels_arr_rel_insert_input
    latitude: numeric
    longitude: numeric
    modems: object_modem_arr_rel_insert_input
    name: String
    navision_id: Int
    phone: String
    provider_id: Int
    provider_name: provider_enum
    users: object_user_rel_arr_rel_insert_input
}

"Boolean expression to filter rows from the table \"object_key\". All fields are combined with a logical 'AND'."
input object_key_bool_exp {
    _and: [object_key_bool_exp!]
    _not: object_key_bool_exp
    _or: [object_key_bool_exp!]
    crew_id: uuid_comparison_exp
    id: uuid_comparison_exp
    object: object_key_rels_bool_exp
    set_name: String_comparison_exp
}

"Boolean expression to filter rows from the table \"object_key_box\". All fields are combined with a logical 'AND'."
input object_key_box_bool_exp {
    _and: [object_key_box_bool_exp!]
    _not: object_key_box_bool_exp
    _or: [object_key_box_bool_exp!]
    crew_id: uuid_comparison_exp
    id: uuid_comparison_exp
    set_name: String_comparison_exp
}

"input type for inserting data into table \"object_key_box\""
input object_key_box_insert_input {
    crew_id: uuid
    id: uuid
    set_name: String
}

"on_conflict condition type for table \"object_key_box\""
input object_key_box_on_conflict {
    constraint: object_key_box_constraint!
    update_columns: [object_key_box_update_column!]! = []
    where: object_key_box_bool_exp
}

"Ordering options when selecting data from \"object_key_box\"."
input object_key_box_order_by {
    crew_id: order_by
    id: order_by
    set_name: order_by
}

"primary key columns input for table: object_key_box"
input object_key_box_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"object_key_box\""
input object_key_box_set_input {
    crew_id: uuid
    id: uuid
    set_name: String
}

"input type for inserting data into table \"object_key\""
input object_key_insert_input {
    crew_id: uuid
    id: uuid
    object: object_key_rels_obj_rel_insert_input
    set_name: String
}

"input type for inserting object relation for remote table \"object_key\""
input object_key_obj_rel_insert_input {
    data: object_key_insert_input!
    "upsert condition"
    on_conflict: object_key_on_conflict
}

"on_conflict condition type for table \"object_key\""
input object_key_on_conflict {
    constraint: object_key_constraint!
    update_columns: [object_key_update_column!]! = []
    where: object_key_bool_exp
}

"Ordering options when selecting data from \"object_key\"."
input object_key_order_by {
    crew_id: order_by
    id: order_by
    object: object_key_rels_order_by
    set_name: order_by
}

"primary key columns input for table: object_key"
input object_key_pk_columns_input {
    id: uuid!
}

"order by aggregate values of table \"object_key_rels\""
input object_key_rels_aggregate_order_by {
    count: order_by
    max: object_key_rels_max_order_by
    min: object_key_rels_min_order_by
}

"input type for inserting array relation for remote table \"object_key_rels\""
input object_key_rels_arr_rel_insert_input {
    data: [object_key_rels_insert_input!]!
    "upsert condition"
    on_conflict: object_key_rels_on_conflict
}

"Boolean expression to filter rows from the table \"object_key_rels\". All fields are combined with a logical 'AND'."
input object_key_rels_bool_exp {
    _and: [object_key_rels_bool_exp!]
    _not: object_key_rels_bool_exp
    _or: [object_key_rels_bool_exp!]
    box_id: uuid_comparison_exp
    id: uuid_comparison_exp
    key: object_key_bool_exp
    key_id: uuid_comparison_exp
    object: object_bool_exp
    object_id: uuid_comparison_exp
}

"input type for inserting data into table \"object_key_rels\""
input object_key_rels_insert_input {
    box_id: uuid
    id: uuid
    key: object_key_obj_rel_insert_input
    key_id: uuid
    object: object_obj_rel_insert_input
    object_id: uuid
}

"order by max() on columns of table \"object_key_rels\""
input object_key_rels_max_order_by {
    box_id: order_by
    id: order_by
    key_id: order_by
    object_id: order_by
}

"order by min() on columns of table \"object_key_rels\""
input object_key_rels_min_order_by {
    box_id: order_by
    id: order_by
    key_id: order_by
    object_id: order_by
}

"input type for inserting object relation for remote table \"object_key_rels\""
input object_key_rels_obj_rel_insert_input {
    data: object_key_rels_insert_input!
    "upsert condition"
    on_conflict: object_key_rels_on_conflict
}

"on_conflict condition type for table \"object_key_rels\""
input object_key_rels_on_conflict {
    constraint: object_key_rels_constraint!
    update_columns: [object_key_rels_update_column!]! = []
    where: object_key_rels_bool_exp
}

"Ordering options when selecting data from \"object_key_rels\"."
input object_key_rels_order_by {
    box_id: order_by
    id: order_by
    key: object_key_order_by
    key_id: order_by
    object: object_order_by
    object_id: order_by
}

"primary key columns input for table: object_key_rels"
input object_key_rels_pk_columns_input {
    box_id: uuid!
    key_id: uuid!
}

"input type for updating data in table \"object_key_rels\""
input object_key_rels_set_input {
    box_id: uuid
    id: uuid
    key_id: uuid
    object_id: uuid
}

"input type for updating data in table \"object_key\""
input object_key_set_input {
    crew_id: uuid
    id: uuid
    set_name: String
}

"order by aggregate values of table \"object_modem\""
input object_modem_aggregate_order_by {
    count: order_by
    max: object_modem_max_order_by
    min: object_modem_min_order_by
}

"input type for inserting array relation for remote table \"object_modem\""
input object_modem_arr_rel_insert_input {
    data: [object_modem_insert_input!]!
    "upsert condition"
    on_conflict: object_modem_on_conflict
}

"Boolean expression to filter rows from the table \"object_modem\". All fields are combined with a logical 'AND'."
input object_modem_bool_exp {
    _and: [object_modem_bool_exp!]
    _not: object_modem_bool_exp
    _or: [object_modem_bool_exp!]
    area_no: String_comparison_exp
    central: central_enum_comparison_exp
    id: uuid_comparison_exp
    object: object_bool_exp
    object_id: uuid_comparison_exp
}

"input type for inserting data into table \"object_modem\""
input object_modem_insert_input {
    area_no: String
    central: central_enum
    id: uuid
    object: object_obj_rel_insert_input
    object_id: uuid
}

"order by max() on columns of table \"object_modem\""
input object_modem_max_order_by {
    area_no: order_by
    id: order_by
    object_id: order_by
}

"order by min() on columns of table \"object_modem\""
input object_modem_min_order_by {
    area_no: order_by
    id: order_by
    object_id: order_by
}

"on_conflict condition type for table \"object_modem\""
input object_modem_on_conflict {
    constraint: object_modem_constraint!
    update_columns: [object_modem_update_column!]! = []
    where: object_modem_bool_exp
}

"Ordering options when selecting data from \"object_modem\"."
input object_modem_order_by {
    area_no: order_by
    central: order_by
    id: order_by
    object: object_order_by
    object_id: order_by
}

"primary key columns input for table: object_modem"
input object_modem_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"object_modem\""
input object_modem_set_input {
    area_no: String
    central: central_enum
    id: uuid
    object_id: uuid
}

"input type for inserting object relation for remote table \"object\""
input object_obj_rel_insert_input {
    data: object_insert_input!
    "upsert condition"
    on_conflict: object_on_conflict
}

"on_conflict condition type for table \"object\""
input object_on_conflict {
    constraint: object_constraint!
    update_columns: [object_update_column!]! = []
    where: object_bool_exp
}

"Ordering options when selecting data from \"object\"."
input object_order_by {
    address: order_by
    city: order_by
    contract_no: order_by
    contract_object_no: order_by
    description: order_by
    id: order_by
    images_aggregate: object_image_aggregate_order_by
    is_atm: order_by
    is_crew_autoasigned: order_by
    keys_aggregate: object_key_rels_aggregate_order_by
    latitude: order_by
    longitude: order_by
    modems_aggregate: object_modem_aggregate_order_by
    name: order_by
    navision_id: order_by
    phone: order_by
    provider_id: order_by
    provider_name: order_by
    users_aggregate: object_user_rel_aggregate_order_by
}

"primary key columns input for table: object"
input object_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"object\""
input object_set_input {
    address: String
    city: city_enum
    contract_no: String
    contract_object_no: String
    description: String
    id: uuid
    is_atm: Boolean
    is_crew_autoasigned: Boolean
    latitude: numeric
    longitude: numeric
    name: String
    navision_id: Int
    phone: String
    provider_id: Int
    provider_name: provider_enum
}

"order by aggregate values of table \"object_user_rel\""
input object_user_rel_aggregate_order_by {
    count: order_by
    max: object_user_rel_max_order_by
    min: object_user_rel_min_order_by
}

"input type for inserting array relation for remote table \"object_user_rel\""
input object_user_rel_arr_rel_insert_input {
    data: [object_user_rel_insert_input!]!
    "upsert condition"
    on_conflict: object_user_rel_on_conflict
}

"Boolean expression to filter rows from the table \"object_user_rel\". All fields are combined with a logical 'AND'."
input object_user_rel_bool_exp {
    _and: [object_user_rel_bool_exp!]
    _not: object_user_rel_bool_exp
    _or: [object_user_rel_bool_exp!]
    is_subscribed_yesterdays_report: Boolean_comparison_exp
    object: object_bool_exp
    object_id: uuid_comparison_exp
    user_id: uuid_comparison_exp
    user_type: user_type_enum_comparison_exp
}

"input type for inserting data into table \"object_user_rel\""
input object_user_rel_insert_input {
    is_subscribed_yesterdays_report: Boolean
    object: object_obj_rel_insert_input
    object_id: uuid
    user_id: uuid
    user_type: user_type_enum
}

"order by max() on columns of table \"object_user_rel\""
input object_user_rel_max_order_by {
    object_id: order_by
    user_id: order_by
}

"order by min() on columns of table \"object_user_rel\""
input object_user_rel_min_order_by {
    object_id: order_by
    user_id: order_by
}

"on_conflict condition type for table \"object_user_rel\""
input object_user_rel_on_conflict {
    constraint: object_user_rel_constraint!
    update_columns: [object_user_rel_update_column!]! = []
    where: object_user_rel_bool_exp
}

"Ordering options when selecting data from \"object_user_rel\"."
input object_user_rel_order_by {
    is_subscribed_yesterdays_report: order_by
    object: object_order_by
    object_id: order_by
    user_id: order_by
    user_type: order_by
}

"primary key columns input for table: object_user_rel"
input object_user_rel_pk_columns_input {
    object_id: uuid!
    user_id: uuid!
}

"input type for updating data in table \"object_user_rel\""
input object_user_rel_set_input {
    is_subscribed_yesterdays_report: Boolean
    object_id: uuid
    user_id: uuid
    user_type: user_type_enum
}

"Boolean expression to filter rows from the table \"objectimages\". All fields are combined with a logical 'AND'."
input objectimages_bool_exp {
    Id: Int_MSSQL_comparison_exp
    _and: [objectimages_bool_exp!]
    _not: objectimages_bool_exp
    _or: [objectimages_bool_exp!]
    defaultimage: String_MSSQL_comparison_exp
    image: binary_MSSQL_comparison_exp
    imagename: String_MSSQL_comparison_exp
    objectid: Int_MSSQL_comparison_exp
}

"upsert condition type for table \"objectimages\""
input objectimages_if_matched {
    match_columns: [objectimages_insert_match_column!]! = []
    update_columns: [objectimages_update_column!]! = []
    where: objectimages_bool_exp
}

"input type for incrementing numeric columns in table \"objectimages\""
input objectimages_inc_input {
    objectid: Int
}

"input type for inserting data into table \"objectimages\""
input objectimages_insert_input {
    defaultimage: String
    image: binary
    imagename: String
    objectid: Int
}

"Ordering options when selecting data from \"objectimages\"."
input objectimages_order_by {
    Id: order_by
    defaultimage: order_by
    image: order_by
    imagename: order_by
    objectid: order_by
}

"primary key columns input for table: objectimages"
input objectimages_pk_columns_input {
    Id: Int!
}

"input type for updating data in table \"objectimages\""
input objectimages_set_input {
    defaultimage: String
    image: binary
    imagename: String
    objectid: Int
}

"Boolean expression to filter rows from the table \"provider\". All fields are combined with a logical 'AND'."
input provider_bool_exp {
    _and: [provider_bool_exp!]
    _not: provider_bool_exp
    _or: [provider_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"provider_enum\". All fields are combined with logical 'AND'."
input provider_enum_comparison_exp {
    _eq: provider_enum
    _in: [provider_enum!]
    _is_null: Boolean
    _neq: provider_enum
    _nin: [provider_enum!]
}

"input type for inserting data into table \"provider\""
input provider_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"provider\""
input provider_on_conflict {
    constraint: provider_constraint!
    update_columns: [provider_update_column!]! = []
    where: provider_bool_exp
}

"Ordering options when selecting data from \"provider\"."
input provider_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: provider"
input provider_pk_columns_input {
    value: String!
}

"input type for updating data in table \"provider\""
input provider_set_input {
    comment: String
    value: String
}

"Boolean expression to filter rows from the table \"reason_for_cancellation\". All fields are combined with a logical 'AND'."
input reason_for_cancellation_bool_exp {
    _and: [reason_for_cancellation_bool_exp!]
    _not: reason_for_cancellation_bool_exp
    _or: [reason_for_cancellation_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"reason_for_cancellation\""
input reason_for_cancellation_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"reason_for_cancellation\""
input reason_for_cancellation_on_conflict {
    constraint: reason_for_cancellation_constraint!
    update_columns: [reason_for_cancellation_update_column!]! = []
    where: reason_for_cancellation_bool_exp
}

"Ordering options when selecting data from \"reason_for_cancellation\"."
input reason_for_cancellation_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: reason_for_cancellation"
input reason_for_cancellation_pk_columns_input {
    value: String!
}

"input type for updating data in table \"reason_for_cancellation\""
input reason_for_cancellation_set_input {
    comment: String
    value: String
}

"Boolean expression to filter rows from the table \"task_type\". All fields are combined with a logical 'AND'."
input task_type_bool_exp {
    _and: [task_type_bool_exp!]
    _not: task_type_bool_exp
    _or: [task_type_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"task_type\""
input task_type_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"task_type\""
input task_type_on_conflict {
    constraint: task_type_constraint!
    update_columns: [task_type_update_column!]! = []
    where: task_type_bool_exp
}

"Ordering options when selecting data from \"task_type\"."
input task_type_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: task_type"
input task_type_pk_columns_input {
    value: String!
}

"input type for updating data in table \"task_type\""
input task_type_set_input {
    comment: String
    value: String
}

"Boolean expression to compare columns of type \"time\". All fields are combined with logical 'AND'."
input time_MSSQL_comparison_exp {
    _eq: time
    _gt: time
    _gte: time
    _in: [time!]
    _is_null: Boolean
    _lt: time
    _lte: time
    _neq: time
    _nin: [time!]
}

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input timestamp_MSSQL_comparison_exp {
    _eq: timestamp
    _gt: timestamp
    _gte: timestamp
    _in: [timestamp!]
    _is_null: Boolean
    _lt: timestamp
    _lte: timestamp
    _neq: timestamp
    _nin: [timestamp!]
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"Boolean expression to compare columns of type \"uniqueidentifier\". All fields are combined with logical 'AND'."
input uniqueidentifier_MSSQL_comparison_exp {
    _eq: uniqueidentifier
    _gt: uniqueidentifier
    _gte: uniqueidentifier
    _in: [uniqueidentifier!]
    _is_null: Boolean
    _lt: uniqueidentifier
    _lte: uniqueidentifier
    _neq: uniqueidentifier
    _nin: [uniqueidentifier!]
}

"Boolean expression to filter rows from the table \"user_settings\". All fields are combined with a logical 'AND'."
input user_settings_bool_exp {
    _and: [user_settings_bool_exp!]
    _not: user_settings_bool_exp
    _or: [user_settings_bool_exp!]
    created_at: timestamptz_comparison_exp
    fusion_auth_id: uuid_comparison_exp
    id: Int_comparison_exp
    imei: String_comparison_exp
    is_logged_in: Boolean_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for incrementing numeric columns in table \"user_settings\""
input user_settings_inc_input {
    id: Int
}

"input type for inserting data into table \"user_settings\""
input user_settings_insert_input {
    created_at: timestamptz
    fusion_auth_id: uuid
    id: Int
    imei: String
    is_logged_in: Boolean
    updated_at: timestamptz
}

"on_conflict condition type for table \"user_settings\""
input user_settings_on_conflict {
    constraint: user_settings_constraint!
    update_columns: [user_settings_update_column!]! = []
    where: user_settings_bool_exp
}

"Ordering options when selecting data from \"user_settings\"."
input user_settings_order_by {
    created_at: order_by
    fusion_auth_id: order_by
    id: order_by
    imei: order_by
    is_logged_in: order_by
    updated_at: order_by
}

"primary key columns input for table: user_settings"
input user_settings_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"user_settings\""
input user_settings_set_input {
    created_at: timestamptz
    fusion_auth_id: uuid
    id: Int
    imei: String
    is_logged_in: Boolean
    updated_at: timestamptz
}

"Boolean expression to filter rows from the table \"user_type\". All fields are combined with a logical 'AND'."
input user_type_bool_exp {
    _and: [user_type_bool_exp!]
    _not: user_type_bool_exp
    _or: [user_type_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"user_type_enum\". All fields are combined with logical 'AND'."
input user_type_enum_comparison_exp {
    _eq: user_type_enum
    _in: [user_type_enum!]
    _is_null: Boolean
    _neq: user_type_enum
    _nin: [user_type_enum!]
}

"input type for inserting data into table \"user_type\""
input user_type_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"user_type\""
input user_type_on_conflict {
    constraint: user_type_constraint!
    update_columns: [user_type_update_column!]! = []
    where: user_type_bool_exp
}

"Ordering options when selecting data from \"user_type\"."
input user_type_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: user_type"
input user_type_pk_columns_input {
    value: String!
}

"input type for updating data in table \"user_type\""
input user_type_set_input {
    comment: String
    value: String
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}

"Boolean expression to compare columns of type \"varbinary\". All fields are combined with logical 'AND'."
input varbinary_MSSQL_comparison_exp {
    _eq: varbinary
    _gt: varbinary
    _gte: varbinary
    _in: [varbinary!]
    _is_null: Boolean
    _lt: varbinary
    _lte: varbinary
    _neq: varbinary
    _nin: [varbinary!]
}
